<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Você sabe que caralhos é um closure?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Você sabe que caralhos é um closure?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Abaixando o nível da conversa…
</section>
<section data-field="body" class="e-content">
<section name="1abe" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0931" id="0931" class="graf graf--h3 graf--leading graf--title">Você sabe que caralhos é um closure?</h3><h4 name="2490" id="2490" class="graf graf--h4 graf-after--h3 graf--subtitle">Abaixando o nível da conversa…</h4><figure name="1b2b" id="1b2b" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*4jXeHRPqKQz7VLiVhUewYg.jpeg" data-width="676" data-height="1024" src="https://cdn-images-1.medium.com/max/800/1*4jXeHRPqKQz7VLiVhUewYg.jpeg"></figure><p name="e946" id="e946" class="graf graf--p graf-after--figure">O <em class="markup--em markup--p-em">closure</em> tem suas origens nas funções anônimas. A ideia era permitir que código executável pudesse ser acessado de uma variável. Digamos que <em class="markup--em markup--p-em">x </em>é esta variável. Assim, poder-se-ia fazer algo como:</p><p name="109e" id="109e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">x()</code></p><p name="49f9" id="49f9" class="graf graf--p graf-after--p">Assim, você consegue parametrizar não apenas dados, mas também ações. A linguagem C implementa essa coisa através de ponteiros para funções, ou seja, uma variável especial que recebe como valor o endereço de memória da primeira instrução de uma determinada função. É possível usar este ponteiro para ativar a função. Porém, esta solução tem um problema: você ainda precisa dar nomes às funções para poder extrair delas o ponteiro.</p><p name="c13e" id="c13e" class="graf graf--p graf-after--p">Normalmente, quando se trabalha com programação orientada a <em class="markup--em markup--p-em">callbacks</em>, que é isto que o <em class="markup--em markup--p-em">closure</em> permite em última instância, ter um nome único para uma função dentro do seu <em class="markup--em markup--p-em">namespace</em> é algo indesejável. Foi assim que nasceram as funções <em class="markup--em markup--p-em">lambda</em>, ou funções anônimas: você declara toda a função mas atribui ela para uma variável ao invés de dar um nome; ou simplesmente a declara <em class="markup--em markup--p-em">in place</em>, onde será usada.</p><p name="2f45" id="2f45" class="graf graf--p graf-after--p">Outra limitação dos ponteiros para função em C é que não é possível capturar variáveis de outro escopo e usá-las dentro da função. Para isto, é necessário que as variáveis sejam, obrigatoriamente, globais, ou pelo menos global na unidade de tradução. Variável global, em C, é uma péssima ideia falando de maneira geral, pois C conta apenas com o <em class="markup--em markup--p-em">namespace</em> global. Não há especializações de <em class="markup--em markup--p-em">namespace</em> como acontece com linguagens mais novas como C++, Java, Swift, etc. Por exemplo, seria possível fazer algo assim em Pascal, por uma questão simples: Pascal permite que funções locais sejam declaradas, enquanto C não permite. Uma função dentro de outra função pode usar as variáveis declaradas no escopo superior. Assim, as variáveis não precisam mais ser globais.</p><h4 name="594c" id="594c" class="graf graf--h4 graf-after--p">Complicações</h4><p name="cd86" id="cd86" class="graf graf--p graf-after--h4">Normalmente toda linguagem que trabalha com <em class="markup--em markup--p-em">closure</em> permite que se declare funções no escopo de funções. Porém, isto tem um preço: a manutenção da pilha torna-se muito mais complexa, principalmente em ambientes nos quais o processo conta com múltiplas linhas de execução. Imagine o seguinte cenário, muito comum para quem programa em Swift para as plataformas Apple: seu método ou função dispara uma atividade em outra thread, mas precisa chamar um <em class="markup--em markup--p-em">callback</em> ao terminar. Este <em class="markup--em markup--p-em">callback</em> é executado sempre em uma determinada thread, normalmente diferente da thread que fez todo o processamento antes de ativar este <em class="markup--em markup--p-em">callback</em>.</p><p name="ce2c" id="ce2c" class="graf graf--p graf-after--p">O <em class="markup--em markup--p-em">callback</em> certamente será ativado bem depois do método ou função no qual foi declarado ter retornado. Se este <em class="markup--em markup--p-em">callback</em> referencia, internamente, alguma variável automática do escopo superior, temos um problema: as variáveis automáticas são extirpadas da pilha tão logo o escopo na qual foram declaradas deixa de ser válido. Mas, se a execução do <em class="markup--em markup--p-em">callback</em> ocorre bem depois do escopo onde tudo foi declarado ter se tornado inválido, fica a pergunta: fodeu?</p><p name="9102" id="9102" class="graf graf--p graf-after--p">Não, não fodeu. O intérprete ou compilador da linguagem teve de ser adaptado para que as variáveis automáticas que tivessem referência dentro de closures tivessem estas referências tratadas como fortes, de forma a não se tornarem inválidas quando o escopo no qual foram declaradas torna-se inválido. Assim, o próprio <em class="markup--em markup--p-em">closure</em>, que também foi declarado em um escopo que torna-se inválido, continua válido e tudo é executado de maneira correta.</p><p name="2b00" id="2b00" class="graf graf--p graf-after--p">O fato é que os intérpretes e compiladores tiveram de sofrer adaptações para que pudessem suportar de maneira transparente a captura de escopo de objetos de uma forma geral. Notem, <em class="markup--em markup--p-em">objeto</em> aqui não é uma instância de uma classe. É um objeto reconhecível pelo seu intérprete ou compilador (variável, função, constante, etc).</p><h4 name="b9fe" id="b9fe" class="graf graf--h4 graf-after--p">Ponteiros para Função</h4><p name="b3f0" id="b3f0" class="graf graf--p graf-after--h4">Os closures são praticamente ponteiros para função, com a diferença que podem capturar objetos que estejam em escopo superior ao que foram declarados, uma característica das linguagens modernas.</p><p name="8586" id="8586" class="graf graf--p graf-after--p">Em alguns casos, a interoperabilidade com linguagens antigas faz com que os closures sejam realmente tratados como ponteiros para função. Por exemplo, ao integrar C com Swift, os <em class="markup--em markup--p-em">callbacks</em> em Swift são closures que são passados como parâmetro para as funções em C que recebem ponteiros para função. Depois abra um <em class="markup--em markup--p-em">playground</em> e experimente usar a função <em class="markup--em markup--p-em">qsort</em> da biblioteca STDC. Você verá que o <em class="markup--em markup--p-em">callback</em> que é, de fato, um ponteiro para função, é traduzido para o Swift como um <em class="markup--em markup--p-em">closure</em>.</p><h4 name="ec57" id="ec57" class="graf graf--h4 graf-after--p">Programação Orientada ao Objeto?</h4><p name="8505" id="8505" class="graf graf--p graf-after--h4">Se olharmos bem o paradigma da POO, veremos que os <em class="markup--em markup--p-em">closures</em> basicamente são um elemento estranho: são funções. Pode-se conseguir algo parecido em Java, por exemplo, que não suporta funções, ao criar métodos de classe. Porém, linguagens como Swift e C++ tornam-se uma miscelânea de funções e objetos interagindo. O fato é que a utilidade dos <em class="markup--em markup--p-em">closures</em> é tão grande que, convenhamos, foda-se a pureza da POO. Afinal nós, programadores, precisamos de ferramentas e linguagens que possam estruturar da forma mais simples o nosso pensamento lógico.</p><p name="0b84" id="0b84" class="graf graf--p graf-after--p">Isto é assunto para outro artigo, porém a programação orientada ao objeto sofreu bastante mudança ao longo dos anos, saindo do modelo <em class="markup--em markup--p-em">waterfall</em> que contextualizava o momento no qual o paradigma foi criado, para o momento atual no qual as mudanças fazem parte de qualquer sistema moderno.</p><p name="5f6f" id="5f6f" class="graf graf--p graf-after--p graf--trailing">Hoje em dia os sistemas tornam-se uma miscelânea de objetos e funções interagindo entre si. Em alguns casos, várias linguagens interoperando dentro do mesmo processo.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/db1814a7992"><time class="dt-published" datetime="2017-10-28T19:28:48.469Z">October 28, 2017</time></a>.</p><p><a href="https://medium.com/@ronaldolima/voc%C3%AA-sabe-que-caralhos-%C3%A9-um-closure-db1814a7992" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>