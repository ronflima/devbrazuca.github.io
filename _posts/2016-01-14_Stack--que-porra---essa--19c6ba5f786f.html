<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Stack: que porra é essa?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Stack: que porra é essa?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Quem estudou algoritmos sabe bem o que é uma pilha. Trata-se de uma estrutura de dados que usa o esquema FILO: First In, Last Out. Ou seja…
</section>
<section data-field="body" class="e-content">
<section name="c1be" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2a36" id="2a36" class="graf graf--h3 graf--leading graf--title">Stack: que porra é essa?</h3><figure name="b283" id="b283" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*F7JbgyRUlEvH4ht_1wzpXg.jpeg" data-width="600" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*F7JbgyRUlEvH4ht_1wzpXg.jpeg"></figure><p name="015c" id="015c" class="graf graf--p graf-after--figure">Quem estudou algoritmos sabe bem o que é uma pilha. Trata-se de uma estrutura de dados que usa o esquema FILO: <em class="markup--em markup--p-em">First In, Last Out.</em> Ou seja, o primeiro elemento a ser colocado na estrutura é o último a ser retirado. Mas, por que a pilha, ou <em class="markup--em markup--p-em">stack</em> é uma estrutura tão importante?</p><p name="c003" id="c003" class="graf graf--p graf-after--p">Você usa pilhas todos os dias, na sua linguagem de programação predileta. Uma estrutura em pilha é usada pelos compiladores e intérpretes para controlar as chamadas de função. Sempre que você chama uma função ou método, o compilador ou intérprete se encarrega de criar uma pilha que controla a profundidade da sua chamada. Abstrato demais?</p><p name="8a85" id="8a85" class="graf graf--p graf-after--p">Imagine que você tenha uma função <em class="markup--em markup--p-em">funcA </em>que chama <em class="markup--em markup--p-em">funcB </em>que, por sua vez, chama <em class="markup--em markup--p-em">funcC</em>. A cada vez que uma função é chamada, o <em class="markup--em markup--p-em">run-time </em>da sua linguagem predileta cria uma pilha com <em class="markup--em markup--p-em">funcA </em>como o primeiro elemento. A pilha é desfeita à medida em que cada função retorna ao seu chamador.</p><p name="7ed5" id="7ed5" class="graf graf--p graf-after--p">A pilha, na verdade, consome memória sem que você saiba. Os compiladores, de uma forma geral, limitam a pilha a um determinado tamanho, visando evitar problemas como a recursão infinita. Quando uma função recursiva com problemas realiza uma recursão infinita, ou seja, a função chama a si mesma repetidamente sem retornar, a pilha atinge seu limite e literalmente estoura. É o que chamamos de <em class="markup--em markup--p-em">estouro de pilha</em>. O compilador pode gerar código para gerar uma exceção no sistema operacional ou pode gerar uma exceção dentro do seu código que pode ser capturada por um tratador de exceções que você escrever.</p><p name="ad84" id="ad84" class="graf graf--p graf-after--p">Por que estou abordando esse assunto? Hoje em dia a estrutura do programa em execução deixou de ter importância aos programadores, que às vezes se vêem à volta com problemas de estouro de pilha sem entender por que isso acontece. Com a popularização do javascript, tornou-se comum criar pilhas de execução enormes devido ao uso indiscriminado de <em class="markup--em markup--p-em">callbacks</em>.</p><p name="bbe6" id="bbe6" class="graf graf--p graf-after--p">Tudo bem, cada entrada na pilha consome uma merreca de memória, quase desprezível. Porém, essa merreca começa a fazer falta em sistemas embarcados nos quais a memória é um recurso extremamente limitado. E realizar o desempilhamento é uma tarefa <em class="markup--em markup--p-em">time consuming </em>para o <em class="markup--em markup--p-em">run-time</em> da sua linguagem favorita. Às vezes é preciso realizar um <em class="markup--em markup--p-em">jump</em> na pilha, forçando um <em class="markup--em markup--p-em">rewind, </em>uma técnica arriscada devido à propensão ao vazamento de memória.</p><p name="2940" id="2940" class="graf graf--p graf-after--p">Este tipo de coisa é comum em sistemas onde cada milissegundo faz a diferença, principalmente em <em class="markup--em markup--p-em">engines </em>de jogos. Cenas podem ser apresentadas com <em class="markup--em markup--p-em">flicker</em> para o jogador caso você não use uma técnica meio radical para retornar de rotinas de renderização.</p><p name="90f8" id="90f8" class="graf graf--p graf-after--p">Em linguagens orientadas ao objeto a pilha tende a ser um pouco mais complexa pois precisa realizar o <em class="markup--em markup--p-em">tracking</em> de qual objeto está acionado. Se estivermos falando de linguagens com <em class="markup--em markup--p-em">garbage collector</em>, o coletor de lixo não pode limpar da existência uma instância que participe de uma chamada ainda não terminada. Ou seja, isso envolve um trabalho extra do <em class="markup--em markup--p-em">run-time</em> para manter a casa em ordem.</p><p name="2f4b" id="2f4b" class="graf graf--p graf-after--p">Este é um dos motivos pelos quais as linguagens procedurais tendem a ter performance muito superior às linguagens orientadas ao objeto. As estruturas usadas dentro do seu <em class="markup--em markup--p-em">run-time</em> são mais simples e realizam tarefas cujo preço em termos de memória e processamento são bem menores.</p><p name="8fc3" id="8fc3" class="graf graf--p graf-after--p graf--trailing">Eu não quero dizer, no entanto, que você deva abandonar sua linguagem orientada ao objeto. Nada disso. Com o aumento de poder de processamento dos processadores atuais, o trabalho extra do <em class="markup--em markup--p-em">run-time</em> é quase irrelevante. Torna-se algo relevante em pequenos sistemas embarcados mas, convenhamos, estamos falando de uma pequena parcela de todos os sistemas que existem pelo globo afora.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/19c6ba5f786f"><time class="dt-published" datetime="2016-01-14T12:01:47.353Z">January 14, 2016</time></a>.</p><p><a href="https://medium.com/@ronaldolima/stack-que-porra-%C3%A9-essa-19c6ba5f786f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>