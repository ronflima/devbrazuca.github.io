<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>iOS: injeção de dependências em View Controllers</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">iOS: injeção de dependências em View Controllers</h1>
</header>
<section data-field="subtitle" class="p-summary">
Injete a dependência e diminua o acoplamento
</section>
<section data-field="body" class="e-content">
<section name="5d99" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="679a" id="679a" class="graf graf--h3 graf--leading graf--title">iOS: injeção de dependências em View Controllers</h3><h4 name="8f19" id="8f19" class="graf graf--h4 graf-after--h3 graf--subtitle">Injete a dependência e diminua o acoplamento</h4><figure name="17e6" id="17e6" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*o1FQJt5Qvr9lXr8unEuo9Q.jpeg" data-width="1136" data-height="756" src="https://cdn-images-1.medium.com/max/800/1*o1FQJt5Qvr9lXr8unEuo9Q.jpeg"></figure><p name="2521" id="2521" class="graf graf--p graf-after--figure">Aqui está o problema: um determinado view controller precisa de dados que são selecionados por outro view controller. O view controller que seleciona os dados navega para o novo view controller que apresenta os dados selecionados. Este é, sem dúvida, o cenário mais comum de qualquer aplicativo iOS, concorda? Por exemplo, um view controller mostra uma lista de itens e o outro mostra os detalhes de um item selecionado pelo usuário.</p><p name="d60b" id="d60b" class="graf graf--p graf-after--p">O problema é: como fazer os dados chegarem lá na frente? Não precisa ser um cenário tão corriqueiro. Imagine que um dos view controllers precisa de um contexto Core Data para demonstrar determinados dados. Como este contexto pode chegar lá?</p><p name="7bc9" id="7bc9" class="graf graf--p graf-after--p">Não importa qual sejam os dados que precisem transitar entre os view controllers. O problema resume-se a um denominador comum: como fazer para injetar dados de um view controller em outro?</p><p name="9409" id="9409" class="graf graf--p graf-after--p">Em uma aplicação que utilize storyboards, a forma recomendada pela Apple para criar a UI atualmente, você tem a possibilidade de injetar dependências quando uma segue é disparada. Portanto, faz parte do mecanismo que vou explicar usar o método <em class="markup--em markup--p-em">prepare(for segue:)</em> para que um view controller injete dados no próximo view controller na estrutura de navegação.</p><p name="e8f6" id="e8f6" class="graf graf--p graf-after--p">Se você não usa storyboards, não poderá usar o método <em class="markup--em markup--p-em">prepare(for segue:)</em> pois as segues são classes específicas para uso em storyboards. Neste caso, o princípio explicado aqui ainda vale, mas você deverá injetar as dependências <em class="markup--em markup--p-em">antes</em> do próximo view controller ser exibido, pois neste cenário você controla a instanciação e a inicialização do view controller manualmente.</p><h4 name="1bbb" id="1bbb" class="graf graf--h4 graf-after--p">O problema da hierarquia</h4><p name="2d7d" id="2d7d" class="graf graf--p graf-after--h4">O próximo view controller na sua navegação pode não ser apenas um view controller, mas uma composição. Por exemplo, um navigation controller tem um root view controller. Um tab bar controller tem uma quantidade arbitrária de child view controllers. Um container pode ter diversos view controllers. Ou seja, o próximo view controller pode não estar sozinho no mundo.</p><p name="4df7" id="4df7" class="graf graf--p graf-after--p">Além disso, o view controller no qual você quer injetar a dependência pode ser o child view controller do próximo view controller. Por exemplo, imagine um aplicativo que tem como root view controller da main window um navigation controller. Agora imagine que você precise injetar dependências no root view controller do navigation controller e, a partir daí, passar as dependências adiante, para cada view controller que tenha a necessidade de usá-las para algum tipo de operação.</p><p name="2dfd" id="2dfd" class="graf graf--p graf-after--p">A injeção de dependências é algo trivial. Porém, em um cenário como o que estou descrevendo, a coisa ficou um pouquinho mais complexa. Mas só um pouquinho. Em termos estruturais, toda, eu disse <strong class="markup--strong markup--p-strong">toda, </strong>aplicação iOS pode ser descrita como um grafo orientado. Para navegar na estrutura da sua aplicação, basta obter-se um nó e navegar pelos outros nós.</p><p name="c969" id="c969" class="graf graf--p graf-after--p">Como todos os nós compartilham da mesma característica, ou seja, são view controllers, podemos generalizar o conceito para um grafo orientado no qual cada nó é igual um ao outro. Percebeu a importância de estudar algoritmos?</p><h4 name="536d" id="536d" class="graf graf--h4 graf-after--p">Recursividade</h4><p name="a484" id="a484" class="graf graf--p graf-after--h4">Bem, já sabemos que podemos descrever um app como um grafo. Temos sempre um ponto de partida, ou seja, sempre podemos partir da janela principal e obter o root view controller dela. A partir daí, podemos navegar livremente pela estrutura da aplicação, até onde há view controllers instanciados.</p><p name="4cfa" id="4cfa" class="graf graf--p graf-after--p">Não dá para propagar a injeção de dependências para a aplicação inteira de uma só vez por que os view controllers são instanciados por demanda. Ou seja, quando sua aplicação inicia-se, somente uma pequena parcela dos view controllers estará instanciada e na memória. Assim, o nosso grafo cresce de acordo com a navegação do usuário.</p><p name="a2c0" id="a2c0" class="graf graf--p graf-after--p">O algoritmo que demonstrarei aqui é recursivo. O fato é que a profundidade de recursão sempre será pequena, mesmo que sua aplicação seja um monstro. Apesar de todas as possibilidades de navegação, o grafo em memória sempre acaba como uma lista, sendo uma árvore com profundidade limitada no pior caso. Assim, a profundidade da recursão sempre será pequena.</p><h4 name="598b" id="598b" class="graf graf--h4 graf-after--p">Protocolos, me salvem!</h4><p name="9a1d" id="9a1d" class="graf graf--p graf-after--h4">Mas, dentro do grafo que é a nossa aplicação, como identificar quais view controllers aceitam as dependências que queremos injetar? Protocolos!</p><p name="e39e" id="e39e" class="graf graf--p graf-after--p">Todo view controller que estiver em conformidade com um protocolo bem determinado estará, automaticamente, eleito para receber a dependência que queremos enfiar nele.</p><p name="9792" id="9792" class="graf graf--p graf-after--p">Portanto, o truque é usar protocolos para saber se o view controller pode receber, ou não a injeção de dependências. Uma forma de implementar isto é esta:</p><pre name="c7b0" id="c7b0" class="graf graf--pre graf-after--p">protocol Injectable: class {<br>    var data: [[String]]! {get set}<br>}</pre><pre name="94ba" id="94ba" class="graf graf--pre graf-after--pre">func inject(into controller: UIViewController, data: [[String]]) {<br>    if let dest = destController as? Injectable {<br>        dest.data = data<br>    }<br>    for child in destController.childViewControllers {<br>        inject(into: child, data: data)<br>    }<br>}</pre><p name="cf4e" id="cf4e" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Injectable </em>é o protocolo que queremos aplicar. Digamos que todo view controller da nossa aplicação que precise de injeção de dependência tenha de estar em conformidade com o protocolo <em class="markup--em markup--p-em">Injectable</em>. Como usaremos somente classes para verificar a conformidade do protocolo, então declaramos o protocolo como somente útil para classes (dica de <a href="https://twitter.com/bgondim" data-href="https://twitter.com/bgondim" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Bruno Bilescky</a>) — isto permite que a verificação da conformidade, e efetiva injeção de dependência seja realizada com um objeto imutável, aumentando a confiabilidade do código. Queremos mudar o estado do objeto, e não o objeto.</p><p name="8d33" id="8d33" class="graf graf--p graf-after--p">A função <em class="markup--em markup--p-em">inject</em> navega recursivamente pela lista de view controllers, injetando a dependência sempre que achar um view controller que está em conformidade com o nosso pequeno protocolo. Por que disso? O fato é que na hierarquia de view controllers, podem existir aqueles que não nos interessam. Assim, é importante navegar em cada nó, entrando recursivamente em cada sub-nó e assim por diante.</p><p name="97a3" id="97a3" class="graf graf--p graf-after--p">Apesar desta rotina recursiva dar um frio na barriga, ela tem uma profundidade pequena e faz a injeção na sua fase ativa.</p><h4 name="1dc5" id="1dc5" class="graf graf--h4 graf-after--p">Como generalizar?</h4><p name="b18b" id="b18b" class="graf graf--p graf-after--h4">O código apresentado até aqui tem como objetivo ilustrar o conceito. Não é ruim usar uma função em uma linguagem orientada ao objeto. Trata-se de um <em class="markup--em markup--p-em">helper</em> funcional, que não tem necessidade de guardar nenhum estado em particular.</p><p name="d2bd" id="d2bd" class="graf graf--p graf-after--p">Porém, uma forma fácil é generalizar este helper para uma estrutura. Por que uma estrutura? Bem, as estruturas são mais eficientes para ativar métodos do que as classes pois, como não suportam herança, não há por que haver uma pesquisa na tabela interna para saber qual método ativar no caso de uma configuração polimórfica: não há polimorfismo nas estruturas.</p><p name="5bdc" id="5bdc" class="graf graf--p graf-after--p">Aqui está uma forma de fazer isso, usando generics:</p><pre name="9bbd" id="9bbd" class="graf graf--pre graf-after--p">struct Injector&lt;ProtocolType, InjectableDataType&gt; {<br>    typealias InjectorCallback = (ProtocolType, InjectableDataType) -&gt; Void<br>    let injector: InjectorCallback</pre><pre name="f35c" id="f35c" class="graf graf--pre graf-after--pre">    init(callback: @escaping InjectorCallback) {<br>        injector = callback<br>    }<br>    <br>    func inject(into controller: UIViewController, data: InjectableDataType) {<br>        if let dest = controller as? ProtocolType {<br>            injector(dest, data)<br>        }<br>        for child in controller.childViewControllers {<br>            inject(into: child, data: data)<br>        }<br>    }<br>}</pre><p name="8878" id="8878" class="graf graf--p graf-after--pre">Tá, a formatação do código está ruim. Não se preocupe. Tem um exemplo completinho no GitHub. Aqui o truque é o seguinte: parametrizamos o protocolo, para verificar a conformidade, e parametrizamos o tipo de dado a injetar. O callback, infelizmente, é necessário. Sem determinarmos os tipos, não há como injetar as dependências de forma tão genérica. Assim, isolamos no callback o conhecimento do que injetar. Aqui está um exemplo de uso:</p><pre name="6896" id="6896" class="graf graf--pre graf-after--p">let injector = Injector&lt;Injectable, [[String]]&gt;(callback {(controller, data) in<br>    controller.data = data<br>})<br>if let rootController = window?.rootViewController {<br>    injector.inject(into: rootController, data: data)<br>}</pre><p name="74db" id="74db" class="graf graf--p graf-after--pre">Aqui injetamos dados [[String]] em controllers que estão em conformidade com o protocolo <em class="markup--em markup--p-em">Injectable</em>. Como usamos um generic para criar nosso injetor de dependências, então é possível fazer isso com virtualmente qualquer protocolo que você precise.</p><p name="2b7c" id="2b7c" class="graf graf--p graf-after--p">Uma generalização possível é alterar o nosso injector para injetar dependências em uma série de protocolos diferentes usando o mesmo código. Isto é potencialmente útil quando temos aplicações complexas com diversos tipos de dependências. Fica como dever de casa ;).</p><h4 name="9984" id="9984" class="graf graf--h4 graf-after--p">Conclusão</h4><p name="ca03" id="ca03" class="graf graf--p graf-after--h4">Bem, amigos. Todo este artigo baseia-se no fato de que uma hierarquia de view controllers é carregada automaticamente pelos storyboards. Tudo funciona por que os view controllers são carregados <strong class="markup--strong markup--p-strong">antes</strong> de suas views. Sabe aquele método mágico <em class="markup--em markup--p-em">viewDidLoad()</em> que todo view controller tem? Pois é, aquilo é para quando a <em class="markup--em markup--p-em">view </em>é carregada. Não tem nada a ver com o que discutimos aqui.</p><p name="6c58" id="6c58" class="graf graf--p graf-after--p">Quando um tab bar controller é instanciado por um storyboard, por exemplo, é garantido que todos os controllers que fazem parte dele comporão o vetor de child view controllers. Este fato é necessariamente verdadeiro para navigation controllers e outras composições. É por este motivo que o truque que expliquei neste artigo funciona.</p><p name="e412" id="e412" class="graf graf--p graf-after--p">Ah, você é São Tomé? Só acredita vendo? Tá bom. <a href="https://github.com/nineteen-apps/SwiftDependencyInjection" data-href="https://github.com/nineteen-apps/SwiftDependencyInjection" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tá aqui um projetinho</a> que demonstra o princípio.</p><p name="30a3" id="30a3" class="graf graf--p graf-after--p">Bom divertimento!</p><p name="0a2f" id="0a2f" class="graf graf--p graf-after--p graf--trailing">Edit 1: Adicionada dica valiosa de <a href="https://twitter.com/bgondim" data-href="https://twitter.com/bgondim" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Bruno Bilescky</a> que se refere à imutabilidade do objeto view controller.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/ed657855d48f"><time class="dt-published" datetime="2016-12-17T01:07:32.200Z">December 17, 2016</time></a>.</p><p><a href="https://medium.com/@ronaldolima/ios-inje%C3%A7%C3%A3o-de-depend%C3%AAncias-em-view-controllers-ed657855d48f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>