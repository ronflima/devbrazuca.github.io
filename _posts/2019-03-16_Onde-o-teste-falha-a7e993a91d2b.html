<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Onde o teste falha</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Onde o teste falha</h1>
</header>
<section data-field="subtitle" class="p-summary">
Não coloque muita fé nos testes automatizados…
</section>
<section data-field="body" class="e-content">
<section name="eac5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="24f2" id="24f2" class="graf graf--h3 graf--leading graf--title">Onde o teste falha</h3><h4 name="0281" id="0281" class="graf graf--h4 graf-after--h3 graf--subtitle">Não coloque muita fé nos testes automatizados…</h4><figure name="b5d8" id="b5d8" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*zamHn75KS7turQ-S99q6tA.jpeg" data-width="1280" data-height="806" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*zamHn75KS7turQ-S99q6tA.jpeg"><figcaption class="imageCaption">Crédito: Pexels.com</figcaption></figure><p name="637d" id="637d" class="graf graf--p graf-after--figure">Antes de começar um aviso: não estou desconsiderando os testes automatizados. A automação de testes tem o seu valor nos projetos modernos de desenvolvimento de software. No entanto, o foco deste artigo é justamente a crítica à fé exacerbada colocada nos testes automatizados, como se fosse uma bala prateada que resolve todos os problemas de qualidade na produção de software.</p><h4 name="ec8e" id="ec8e" class="graf graf--h4 graf-after--p">Qualidade de software</h4><p name="8df3" id="8df3" class="graf graf--p graf-after--h4">Ao longo dos anos a indústria de desenvolvimento vem tentando comoditizar o desenvolvimento de software através da automação e da contratação de desenvolvedores cada vez menos experientes e com menor conhecimento. Infelizmente, desenvolver software é quase como cozinhar: quanto mais conhecimento e quanto mais experiência tem o cozinheiro, melhor a comida.</p><p name="8970" id="8970" class="graf graf--p graf-after--p">A qualidade de software não está na abrangência dos testes e, muito menos, no detalhamento das especificações: está na qualidade do que o developer escreve. Escrever software é um processo que precisa ser treinado diariamente para que seja efetivo. Quanto mais software você escreve, melhor você fica nisso. Da mesma forma, quanto mais linguagem de programação você aprende, melhor fica sua fluência na linguagem que você usa no dia-a-dia pois você aprende formas diferentes, e mais otimizadas, de escrever a mesma coisa.</p><p name="1cb4" id="1cb4" class="graf graf--p graf-after--p">Assim, o ponto central na qualidade do seu software não está na qualidade dos seus testes, mas na qualidade daquilo que você coloca no repositório para virar o produto que seu usuário vai usar.</p><h4 name="5a38" id="5a38" class="graf graf--h4 graf-after--p">Cenários onde o teste falha</h4><p name="2030" id="2030" class="graf graf--p graf-after--h4">Nenhuma abordagem de testes é livre de falhas, principalmente no que diz respeito aos testes automatizados. A verdade é que os testes automatizados são uma das diversas ferramentas disponíveis ao alcance do desenvolvedor. E antes que me digam que estou metendo o pau nos testes automatizados, consulte a <a href="https://github.com/ronflima/feijuca" data-href="https://github.com/ronflima/feijuca" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">biblioteca Feijuca no GitHub</a>. Ela faz uso de testes automatizados e de integração contínua, apesar de ainda não ter implementado geração de nightly builds por completa falta de tempo.</p><p name="33ec" id="33ec" class="graf graf--p graf-after--p">Mas é importante ter em mente que os testes não resolvem tudo. E aqui vão alguns exemplos. Imagine que você tenha desenvolvido uma classe para compor um determinado componente numa relação de composição. Você escreveu os testes unitários para verificar o funcionamento da classe de acordo com as especificações. Onde é que seus testes falham?</p><p name="2871" id="2871" class="graf graf--p graf-after--p">Como toda classe, ao instanciar um objeto o seu código será responsável pela manutenção do estado interno deste objeto. Os estímulos externos, que chegam através dos métodos públicos ou protegidos da sua classe, alteram os estados internos. Porém, os testes executam pela interface, acessando exclusivamente aquilo que a classe torna público. Como validar o estado interno?</p><p name="6e2a" id="6e2a" class="graf graf--p graf-after--p">Se a linguagem for Java, esqueça. Privado é privado e não há como saber o que está lá dentro. Se for C++, você rompe o encapsulamento através do uso de funções ou classes amigas. Linguagens cujo modelo de orientação ao objeto são simplificados, como Javascript ou Python, permitem que você acesse o estado interno dos objetos sem problemas. Mas, a despeito disso, o <em class="markup--em markup--p-em">encapsulamento </em>é algo que precisa ser mantido pois é uma característica intrínseca da POO, algo que independe da linguagem.</p><p name="b099" id="b099" class="graf graf--p graf-after--p">Assim, se um objeto da sua classe assume um estado inválido, o seu teste não será capaz de verificá-lo, mesmo por que o teste, a rigor, precisa conhecer o estado do objeto através do que está exposto. Em vários projetos já vi manutenções predatórias que resolveram a comunicação da interface mantendo o objeto em um estado inválido, mesmo que a classe gerasse respostas corretas.</p><p name="63c2" id="63c2" class="graf graf--p graf-after--p">Quando se faz teste de funções, também, a ideia prevalece: não é possível avaliar o estado interno das funções estando do lado de fora. Injetar código para avaliar a função por dentro resolveria o problema, mas cria outro: altera o balanço de tempo da função, o que é basicamente ruim quando o seu código é dependente do tempo, por exemplo, em uma arquitetura de múltiplas threads.</p><h4 name="35eb" id="35eb" class="graf graf--h4 graf-after--p">Como resolver isso?</h4><p name="352a" id="352a" class="graf graf--p graf-after--h4">Acabei por descrever uma limitação dos testes automatizados. Porém, não deixe de usar testes automatizados por conta disso. O que eu quis mostrar é que existem limitações com as quais você precisa lidar e cuja importância é enorme, pois não expõem manutenções predatórias.</p><p name="6b93" id="6b93" class="graf graf--p graf-after--p">A forma melhor de resolver este impasse é através de outra ferramenta chamada <em class="markup--em markup--p-em">argumentação de algoritmos</em>. Mais um exemplo de limitação dos testes: como você faria para testar completamente uma função que receba um número de ponto flutuante e calcule a raiz quadrada deste número?</p><p name="b19e" id="b19e" class="graf graf--p graf-after--p">Para o teste ser completo, você precisa testar esta função com relação a todos os números positivos de 0 ao máximo valor de representação em ponto flutuante, não se esquecendo de passar por todos os números passíveis de representação entre os números inteiros. Matematicamente falando, entre 0 e 1 há infinitos números. No computador a quantidade é finita, mas muito, muito grande. E aí? Vai escrever cenários de testes para isso tudo?</p><p name="a4df" id="a4df" class="graf graf--p graf-after--p">É aqui que a argumentação de algoritmos entra em cena:</p><blockquote name="a6ec" id="a6ec" class="graf graf--blockquote graf-after--p">A invariante de entrada leva à invariante de saída.</blockquote><p name="a90c" id="a90c" class="graf graf--p graf-after--blockquote">Invariante é algo que você considera como correto em determinado trecho do seu código. Assim, para argumentar a corretude do seu código, é importante avaliar se a invariante de entrada está levando, de fato, à invariante de saída. E a verificação de invariantes é realizada com <em class="markup--em markup--p-em">assertivas</em>.</p><p name="e812" id="e812" class="graf graf--p graf-after--p">Assim, refraseando:</p><blockquote name="fdd7" id="fdd7" class="graf graf--blockquote graf-after--p">A assertiva de entrada leva à assertiva de saída.</blockquote><p name="1f17" id="1f17" class="graf graf--p graf-after--blockquote">Ou seja, o estado de entrada, depois de processado, é o estado de saída. No exemplo da função que calcula raízes quadradas, você pode verificar a corretude do seu algoritmo dessa forma:</p><figure name="eed9" id="eed9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/ronflima/20ca85f962bd32b16c6d7897c55c310f.js.js"></script></figure><p name="d3f9" id="d3f9" class="graf graf--p graf-after--figure">Não importa como a raiz é calculada por que não é o foco deste texto. Se quiser uma ideia do algoritmo, <a href="https://www.codeproject.com/Articles/570700/SquareplusRootplusalgorithmplusforplusC" data-href="https://www.codeproject.com/Articles/570700/SquareplusRootplusalgorithmplusforplusC" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">aqui há um exemplo</a>. O foco são as assertivas: note que consideramos que a entrada precisa ser, necessariamente, maior ou igual a zero, pois consideramos que uma entrada negativa não é passível de calcular a raiz quadrada, considerando que a função trabalha exclusivamente no domínio dos números reais.</p><p name="4e21" id="4e21" class="graf graf--p graf-after--p">Assim, testamos a primeira invariante: a entrada não pode ser negativa. Feito o cálculo da raiz quadrada, testamos a saída, ou seja, o resultado, se multiplicado por si mesmo, é a entrada. Esta é a invariante de saída.</p><p name="1eb9" id="1eb9" class="graf graf--p graf-after--p">Assim, com o auxílio das assertivas, o teste automatizado consegue verificar estados internos. Alguns autores sugerem manter as assertivas em código de produção. No entanto, as assertivas tendem a gerar pânico no código, pois o processo será terminado de forma arbitrária. Arquivos abertos terão <em class="markup--em markup--p-em">buffers </em>perdidos, transações pendentes serão perdidas e por aí vai. Ou seja, não concordo com isso. Porém, há quem concorde e com argumentos muito fortes defendendo seus pontos-de-vista. Deixo o julgamento do mérito para você.</p><h4 name="e114" id="e114" class="graf graf--h4 graf-after--p">Conclusão</h4><p name="9ff0" id="9ff0" class="graf graf--p graf-after--h4">Como eu disse no início, não coloque muita fé nos testes automatizados. São ferramentas úteis, mas falhas, como toda ferramenta. Há como melhorar os testes com o uso de assertivas. Os testes são importantes, mas não se deve colocar a garantia completa da qualidade do seu software neles.</p><p name="a3ff" id="a3ff" class="graf graf--p graf-after--p">É importante que o seu código, antes de mais nada, seja bom. E para que seu código seja bom é preciso que você tenha muita prática, estude bastante e capacite-se sempre. O trabalho de desenvolvedor de software exige o desenvolvimento do desenvolvedor. Ou seja, o desenvolvedor está sempre aprendendo. E isto é uma necessidade.</p><p name="3a99" id="3a99" class="graf graf--p graf-after--p graf--trailing">Happy Coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/a7e993a91d2b"><time class="dt-published" datetime="2019-03-16T13:11:45.558Z">March 16, 2019</time></a>.</p><p><a href="https://medium.com/@ronaldolima/onde-o-teste-falha-a7e993a91d2b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>