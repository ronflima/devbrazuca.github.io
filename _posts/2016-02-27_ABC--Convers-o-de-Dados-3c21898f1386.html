<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>ABC: Conversão de Dados</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">ABC: Conversão de Dados</h1>
</header>
<section data-field="subtitle" class="p-summary">
Transformar quadrados em círculos é uma tarefa comum que todo desenvolvedor de software faz. Porém, sua importância é negligenciada.
</section>
<section data-field="body" class="e-content">
<section name="815c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c653" id="c653" class="graf graf--h3 graf--leading graf--title">ABC: Conversão de Dados</h3><h4 name="8473" id="8473" class="graf graf--h4 graf-after--h3 graf--subtitle">Transformar quadrados em círculos é uma tarefa comum que todo desenvolvedor de software faz. Porém, sua importância é negligenciada.</h4><figure name="1a37" id="1a37" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*IROxz9Nbba3fQ2glItVz4A.png" data-width="1600" data-height="564" src="https://cdn-images-1.medium.com/max/800/1*IROxz9Nbba3fQ2glItVz4A.png"></figure><p name="7429" id="7429" class="graf graf--p graf-after--figure">Todo programador converte dados sempre que escreve um programa: você lê os dados do teclado ou de um arquivo, formata-os em uma ou mais estruturas de dados que compõem um grafo que implementa um determinado modelo e, por fim, você converte novamente em tabelas para que possa salvar essa coisa toda num database qualquer.</p><p name="3b8c" id="3b8c" class="graf graf--p graf-after--p">Tem novidade? Claro que não. Isso é lugar comum. Porém, a conversão de dados é algo negligenciado e aqui apresento um princípio simples mas que pode ser amplamente aplicado em qualquer linguagem de programação. Toda essa firula para falar dos <em class="markup--em markup--p-em">construtores de conversão</em>, uma construção que existe na linguagem C++. Várias linguagens contemporâneas ao C++ implementaram algo parecido: java, C# com os operadores implícitos e explícitos e por aí vai.</p><p name="770d" id="770d" class="graf graf--p graf-after--p">Por definição, um construtor de conversão recebe apenas um parâmetro cujo tipo é diferente da classe que está construindo. Assim, se você tem uma classe A que tem um construtor de conversão de uma classe B, você pode fazer algo como:</p><blockquote name="f11a" id="f11a" class="graf graf--pullquote graf-after--p">B b = B();</blockquote><blockquote name="779b" id="779b" class="graf graf--pullquote graf-after--pullquote">A a = b;</blockquote><p name="98f7" id="98f7" class="graf graf--p graf-after--pullquote">Implicitamente o compilador chamará o construtor de conversão ao construir a instância que será o objeto <em class="markup--em markup--p-em">a</em>. Assim, sempre que precisar converter B para A, basta construir um objeto de A usando uma instância de B. Simples assim.</p><p name="0bae" id="0bae" class="graf graf--p graf-after--p">Mas não quero falar de C++. A ideia aqui é usar o princípio do construtor de conversão. Ou seja, sempre que você precisar converter de uma estrutura para outra, você constrói a nova estrutura com base na antiga usando, para isso, alguma forma de componentização, seja por uma função no caso das linguagens procedurais, seja por um método maceteado, no caso das linguagens orientadas ao objeto.</p><p name="fb62" id="fb62" class="graf graf--p graf-after--p">Isso simplifica a sua vida pois o código da conversão fica consistente. É bem melhor do que você fazer algo do tipo:</p><blockquote name="8a92" id="8a92" class="graf graf--pullquote graf-after--p">B b = B();</blockquote><blockquote name="978b" id="978b" class="graf graf--pullquote graf-after--pullquote">A a = A();</blockquote><blockquote name="f53c" id="f53c" class="graf graf--pullquote graf-after--pullquote">a.prop1 = b.prop3;</blockquote><blockquote name="c20c" id="c20c" class="graf graf--pullquote graf-after--pullquote">a.prop2 = b.prop4;</blockquote><p name="6292" id="6292" class="graf graf--p graf-after--pullquote">Fazer desse jeito faz com que o mapeamento dos dados seja implementado sempre que você precisar realizar a conversão, ou seja, você vai escrever o mesmo mapeamento várias vezes. Ao invés disso, é melhor criar uma função ou método que faça isso, pois você concentra tudo no mesmo lugar. Se você usa uma linguagem orientada ao objeto, ficará tentado a criar um <em class="markup--em markup--p-em">helper. </em>Eu sou um pouco contrário a essa ideia do <em class="markup--em markup--p-em">helper</em> pois trata-se de uma função que, via de regra, infringe o paradigma de orientação ao objeto.</p><p name="bf5d" id="bf5d" class="graf graf--p graf-after--p">Bem, quase toda linguagem tem alguma forma de construção que facilita a conversão de dados. C#, por exemplo, tem os operadores explícitos que permitem construir um conversor de dados bastante eficiente, o que leva a uma sintaxe de conversão assim:</p><blockquote name="38c8" id="38c8" class="graf graf--pullquote graf-after--p">A a = (A)b;</blockquote><p name="c79b" id="c79b" class="graf graf--p graf-after--pullquote">O interessante disso é que a sintaxe deixa clara a intenção: estamos convertendo explicitamente uma instância de B em uma instância de A.</p><p name="cc2c" id="cc2c" class="graf graf--p graf-after--p">É possível, também, usar os operadores implícitos. A semântica não fica tão evidente, mas ao perceber que você está atribuindo uma instância de B para A, percebe-se que há algo acontecendo além da atribuição:</p><blockquote name="cd94" id="cd94" class="graf graf--pullquote graf-after--p">A a = b;</blockquote><h4 name="9905" id="9905" class="graf graf--h4 graf-after--pullquote">A importância do data mapping</h4><p name="126a" id="126a" class="graf graf--p graf-after--h4">A conversão é apenas uma faceta disso que estou falando. O mapeamento de dados necessário para a conversão é algo que precisa ficar bem explícito no seu código. Isso facilita a sua vida e simplifica a implementação de qualquer solução que você venha a criar.</p><p name="0b24" id="0b24" class="graf graf--p graf-after--p">Não importa como você fará o mapeamento de dados, se campo a campo ou usando alguma técnica mais rebuscada. O importante é que o mapeamento de dados seja explícito e, de preferência, centralizado no seu código. Assim, se houver alguma alteração em alguma estrutura de dados você poderá, facilmente, alterar o mapeamento.</p><h4 name="6ecb" id="6ecb" class="graf graf--h4 graf-after--p">Nada de novo</h4><p name="9ff8" id="9ff8" class="graf graf--p graf-after--h4">Não existe, absolutamente, nada de novo no que escrevi até aqui. O mapeamento de dados é um conceito antigo que, porém, é negligenciado por programadores. Existem diversas formas de mapear dados de um tipo para outro. A melhor forma é aquela que é a mais simples, explícita e fácil de manter.</p><p name="ba8e" id="ba8e" class="graf graf--p graf-after--p">Não invente moda com algoritmos sofisticados. O algoritmo sofisticado dá erro sofisticado. Ou seja, o bug fixing vai fazer você perder várias horas de sono.</p><p name="c4cb" id="c4cb" class="graf graf--p graf-after--p graf--trailing">É importante compreender os modelos de dados e entender como converter um modelo em outro dentro do seu sistema. Em outro artigo vou escrever um pouco da heretogeneidade dos modelos de dados dentro do domínio de um único sistema, abordando por que isso é uma boa ideia ao invés de tentar chegar a um modelo universal e único.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/3c21898f1386"><time class="dt-published" datetime="2016-02-27T15:26:28.916Z">February 27, 2016</time></a>.</p><p><a href="https://medium.com/@ronaldolima/abc-convers%C3%A3o-de-dados-3c21898f1386" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>