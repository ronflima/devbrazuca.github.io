<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>O Modelamento Relacional</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">O Modelamento Relacional</h1>
</header>
<section data-field="subtitle" class="p-summary">
E por que ignorá-lo é uma péssima ideia
</section>
<section data-field="body" class="e-content">
<section name="2bc5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="49c5" id="49c5" class="graf graf--h3 graf--leading graf--title">O Modelamento Relacional</h3><h4 name="574c" id="574c" class="graf graf--h4 graf-after--h3 graf--subtitle">E por que ignorá-lo é uma péssima ideia</h4><figure name="685a" id="685a" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*gPOuqhPzpLX9GLL0d4F2_w.jpeg" data-width="1024" data-height="768" src="https://cdn-images-1.medium.com/max/800/1*gPOuqhPzpLX9GLL0d4F2_w.jpeg"></figure><p name="bfa4" id="bfa4" class="graf graf--p graf-after--figure">Vivemos num mundo que é regido, atualmente, pelo ORM. Muita gente deposita sua fé cegamente no <em class="markup--em markup--p-em">Object-relational Mapping</em> e esquece-se de que, no fim, os dados serão armazenados no velho banco de dados relacional.</p><h4 name="2576" id="2576" class="graf graf--h4 graf-after--p">Por que o ORM é bom</h4><p name="d2e7" id="d2e7" class="graf graf--p graf-after--h4">Antes que me falem que estou metendo o pau no ORM, deixe-me dizer que eu uso ORMs no meu dia-a-dia. É prático, é fácil de usar e economiza um tempo miserável. E tem uma grande vantagem: permite que você escreva código que fica independente do banco de dados.</p><p name="94cd" id="94cd" class="graf graf--p graf-after--p">No passado era necessário escrever um adapter e uma montanha de drivers para fazer com que o código ficasse independente de SGDB. Era um saco, tomava um tempo do inferno e todo adapter acabava ficando muito específico. Além disso, era necessário criar um DDL para cada banco de dados. Migração? Tome DMLs complexos.</p><p name="d800" id="d800" class="graf graf--p graf-after--p">O ORM elimina toda a trabalheira que dá manter um banco de dados relacional do ponto-de-vista do developer.</p><h4 name="7e89" id="7e89" class="graf graf--h4 graf-after--p">Por que você precisa entender o modelo relacional</h4><p name="2b61" id="2b61" class="graf graf--p graf-after--h4">Apesar de todos os benefícios do ORM, é importante conhecer-se o modelo relacional. E o motivo é muito simples: existem alguns truques que só funcionam para o modelo relacional e que são bem complicados de fazer com um ORM.</p><p name="98f0" id="98f0" class="graf graf--p graf-after--p">A verdade é que o ORM é construído sobre uma premissa muito simples: a normalização dos dados. Mas, e o que acontece quando você precisa denormalizar os dados por algum motivo? Até há alguns anos atrás os puristas metiam o pau na denormalização. Hoje em dia a denormalização de dados é algo tão corriqueiro que os bancos de dados vedetes são todos NOSQL, ou seja, trabalham basicamente com dados denormalizados.</p><p name="a4ac" id="a4ac" class="graf graf--p graf-after--p">Entender o modelo relacional, portanto, te ajuda a modelar melhor seu grafo de objetos, além de lhe dar ferramentas para criar elementos no banco de dados que o permitem usar o melhor dos dois mundos.</p><h4 name="350b" id="350b" class="graf graf--h4 graf-after--p">Relatórios, views e tabelas denormalizadas</h4><p name="0d46" id="0d46" class="graf graf--p graf-after--h4">Criar relatórios em sistemas é uma tarefa corriqueira. Quase todo sistema de informação exige algum tipo de relatório para o usuário final. Porém, criar relatórios usando um ORM pode ser simples, do ponto-de-vista de quem escreve o código, mas normalmente leva a sistemas lentos pois os acessos podem tornar-se complexos e envolver diversas entidades do banco de dados sem que o programador tenha noção disso.</p><p name="dab0" id="dab0" class="graf graf--p graf-after--p">É neste quesito que alguns elementos do SGBD se sobressaem. As <em class="markup--em markup--p-em">Views</em> permitem que os relatórios sejam gerados de forma simples, mesmo que sejam construídas por sobre diversas tabelas. As views já tem o plano de acesso computado e não é preciso que o database realize esta tarefa durante uma query. Por si só isto já é uma excelente otimização. Sim, alguns SGDBs fazem cache de planos de acesso, porém a view não precisa ter o plano de acesso calculado pois isto é feito quando a mesma é criada no database.</p><p name="47ae" id="47ae" class="graf graf--p graf-after--p">Ao usar uma view, o acesso para gerar o seu relatório torna-se extremamente simples e muito mais eficiente. Ao invés de criar um statement complexo, cheio de outer e inner joins, basta executar um select simples. Do ponto-de-vista de um ORM, basta realizar um filtro simples, sem quase nenhum código.</p><p name="c9bc" id="c9bc" class="graf graf--p graf-after--p">Pelo menos os ORMs com os quais já trabalhei não suportam views, pelo menos não diretamente. É possível mapeá-las como classes do ORM, mas não é possível criá-las como um elemento do ORM em si, ou seja, deixá-las para o ORM cuidar delas.</p><p name="85df" id="85df" class="graf graf--p graf-after--p">Outra técnica interessante é o uso de tabelas denormalizadas para consumo de informações. A principal vantagem é que toda a informação está lá, pronta para o consumo, sem a necessidade de queries complicadas. A diferença com relação às views, é que o acesso é muito mais rápido pois não é necessário buscar dados em data files diferentes, algo que pode acontecer com uma view. O Oracle, por exemplo, permite uma construção chamada de <em class="markup--em markup--p-em">materialized view</em>, que é uma view que ocupa espaço em um data file. A <em class="markup--em markup--p-em">materialized view</em> é, na verdade, uma tabela que mantém um <em class="markup--em markup--p-em">snapshot </em>de uma query. Infelizmente, precisa ser atualizada para que o <em class="markup--em markup--p-em">snapshot </em>de dados reflita novas inserções, atualizações e remoções.</p><p name="7d1a" id="7d1a" class="graf graf--p graf-after--p">A forma mais simples é manter estas tabelas denormalizadas atualizadas com <em class="markup--em markup--p-em">triggers</em>. Pode-se, também, usar stored procedures disparadas por um script cron para manter estas tabelas atualizadas. O principal conceito é que as tabelas denormalizadas podem ser usadas por sistemas que precisam ter acesso a dados rápido quando o volume é muito alto a ponto de inviabilizar uma query direta no modelo relacional.</p><p name="c522" id="c522" class="graf graf--p graf-after--p">Este é um truque que é difícil de realizar com um ORM pois cria um grafo de classes bem esquisito, com replicações. Na minha visão, o grafo de classes precisa ser, necessariamente, um modelo dos dados sobre os quais a aplicação trabalha. Os macetes para ganhar performance e minimizar tempos de acesso e latência de rede são otimizações que não deveriam fazer parte do modelo de negócio de uma aplicação, mas parte do modelo de implementação.</p><p name="c52f" id="c52f" class="graf graf--p graf-after--p">De toda forma, estes truques só são possíveis, hoje em dia, se há conhecimento do modelo de entidades e relacionamentos sobre o qual os SGDBs clássicos são construídos. Porém, quando falamos de NOSQL, o buraco é bem mais embaixo…</p><h4 name="9f1d" id="9f1d" class="graf graf--h4 graf-after--p">NOSQL e ORM: um romance que não pode dar certo</h4><p name="4f66" id="4f66" class="graf graf--p graf-after--h4">Aqui está uma coisa esquisita: criar um ORM para um banco NOSQL. É quase como forçar um cavalo a cruzar com uma vaca só por que os dois são quadrúpedes. A premissa sobre a qual um banco NOSQL é construído é completamente diferente da premissa sobre a qual um ORM é construído. Não há relacionamentos nos bancos NOSQL. Por exemplo, o Cassandra, que é um banco NOSQL baseado em Big Tables, não permite chaves estrangeiras por uma questão simples: as tabelas podem ser distribuídas em várias máquinas através de uma técnica chamada de <em class="markup--em markup--p-em">sharding</em>.</p><p name="0767" id="0767" class="graf graf--p graf-after--p">Com o MongoDB isto também pode acontecer, ou seja, uma árvore inteira pode ser distribuída por um conjunto de máquinas. Isto torna a atualização de relacionamentos entre informações algo custoso, complexo e suficientemente lento para ser parte de um database deste tipo. No caso específico do MongoDB, a coisa ainda é mais complicada: o <em class="markup--em markup--p-em">schema</em> do banco de dados não precisa ser criado <em class="markup--em markup--p-em">a priori</em> para que as informações sejam persistidas.</p><p name="5248" id="5248" class="graf graf--p graf-after--p">Como o ORM foi construído para um mundo de objetos e relacionamentos, usar um NOSQL por baixo disso é uma tarefa muito complicada. Existem já adapters para ORMs, mas imagino o quanto isso deve ser complicado <em class="markup--em markup--p-em">under the hood, </em>principalmente para manter as atualizações em cascata entre entidades em composições.</p><p name="b0e0" id="b0e0" class="graf graf--p graf-after--p">A própria sigla do ORM já dá uma visão do que para que serve a ideia: mapeamento de objetos e relacionamentos. Ou seja, se não há relacionamento, como mapear a coisa toda? É possível? Sim, é possível. Mas a que custo?</p><h4 name="f6d9" id="f6d9" class="graf graf--h4 graf-after--p">Adapters</h4><p name="b514" id="b514" class="graf graf--p graf-after--h4">Bom, antes de ir vale a pena lembrar de um <em class="markup--em markup--p-em">design pattern</em> muito útil quando se pretende suportar diversos bancos de dados na mesma aplicação. Basta fazer com que todo o acesso seja feito através de um <em class="markup--em markup--p-em">adapter</em>. Isto faz com que todo o acesso ao SGDB seja isolado em módulos bem definidos, fazendo com que o restante da sua aplicação permaneça independente do banco de dados.</p><p name="743f" id="743f" class="graf graf--p graf-after--p">Esta é, na verdade, uma técnica bastante antiga e dispendiosa em termos de desenvolvimento, pois os adapters funcionam de forma muito específica, sendo muito dependentes do domínio da sua aplicação. Sim, é possível generalizar para que os adapters retornem objetos genéricos, como listas de dicionários por exemplo.</p><p name="7388" id="7388" class="graf graf--p graf-after--p">Por que estou falando disso? Trata-se de uma alternativa boa aos ORMs quando os ORMs não atendem às necessidades. Note: não estou falando para você não usar ORMs. O que estou dizendo é que os ORMs não conseguem cobrir todos os cenários.</p><p name="5157" id="5157" class="graf graf--p graf-after--p graf--trailing">Happy Coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/a532f27eddc9"><time class="dt-published" datetime="2018-05-03T09:41:15.170Z">May 3, 2018</time></a>.</p><p><a href="https://medium.com/@ronaldolima/o-modelamento-relacional-a532f27eddc9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>