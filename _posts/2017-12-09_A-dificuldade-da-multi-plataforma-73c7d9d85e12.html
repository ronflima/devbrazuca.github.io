<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>A dificuldade da multi-plataforma</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">A dificuldade da multi-plataforma</h1>
</header>
<section data-field="subtitle" class="p-summary">
Por que o software multi-plataforma consome mais recursos
</section>
<section data-field="body" class="e-content">
<section name="96ae" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1de0" id="1de0" class="graf graf--h3 graf--leading graf--title">A dificuldade da multi-plataforma</h3><h4 name="3e64" id="3e64" class="graf graf--h4 graf-after--h3 graf--subtitle">Por que o software multi-plataforma consome mais recursos</h4><figure name="cb39" id="cb39" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*nrRtgIStDFLxscroNTv0OQ.png" data-width="1024" data-height="680" src="https://cdn-images-1.medium.com/max/800/1*nrRtgIStDFLxscroNTv0OQ.png"></figure><p name="51bc" id="51bc" class="graf graf--p graf-after--figure">Escrever software multi-plataforma não é, e nunca foi, algo fácil. Cada plataforma tem premissas próprias, distintas entre si. E as diferenças forçam a criação de camadas de compatibilidade que precisam ser específicas para cada plataforma. Não existe mágica: apenas engenharia.</p><p name="c521" id="c521" class="graf graf--p graf-after--p">Antes que você julgue este artigo: não estou criticando o software multi-plataforma. Na verdade, escrevo software multi-plataforma há anos. E venho de uma época na qual haviam diferenças até mesmo no sistema Unix, que dependia de quem vendia: IBM com seu AIX, HP com o HPUX, Microsoft com o Xenix, Santa Cruz Operation (hoje subsidiária da Microsoft), com seu SCO Unix, Compaq com seu Tru64, Sun com seu Solaris, Silicon Graphics com o seu IRIX.</p><h4 name="fa67" id="fa67" class="graf graf--h4 graf-after--p">A Camada Mais Baixa: interagindo com o SO</h4><p name="2f03" id="2f03" class="graf graf--p graf-after--h4">Não importa qual é o tipo de software que você escreva. Cedo ou tarde ele precisa, necessariamente, interagir com o sistema operacional no qual está rodando. Ah, mas o seu software é web? Sério? Quem você acha que entrega os eventos de mouse e teclado para a sua página? Apesar do software muitas vezes executar dentro de um <em class="markup--em markup--p-em">sandbox </em>qualquer, ele vai interagir com o sistema operacional através do <em class="markup--em markup--p-em">sandbox</em>. E aqui está a primeira camada do seu <em class="markup--em markup--p-em">runtime:</em> a camada que compatibiliza o seu software com o sistema operacional.</p><p name="ecfb" id="ecfb" class="graf graf--p graf-after--p">Esta camada do seu software é responsável por funções de baixo nível: comunicação de rede, renderização da interface com o usuário, recepção e processamento de eventos como cliques, movimentação do mouse, eventos de teclado, etc. Vai abrir um arquivo? Esta camada gerencia como o arquivo será aberto, como será lido. Vai disparar um evento assíncrono? A camada de baixo nível cria as threads, mesmo que você não o faça explicitamente no seu código.</p><p name="1e60" id="1e60" class="graf graf--p graf-after--p">Cada sistema tem uma forma bem diferente de fazer as coisas. No Windows, para criar um arquivo é necessário executar um <em class="markup--em markup--p-em">system call </em>chamado <em class="markup--em markup--p-em">CreateFile</em>. No Unix, <em class="markup--em markup--p-em">open</em> pode fazer o trabalho. A camada de baixo nível compatibiliza seu código com o sistema operacional evitando que você precise fazer chamadas explícitas de sistema.</p><p name="f190" id="f190" class="graf graf--p graf-after--p">A questão aqui é que cada sistema de uma forma muito diferente de fazer as coisas o que torna essa camada algo bem complexo de ser feito no intuito de manter a compatibilidade do seu software com os sistemas operacionais.</p><h4 name="0644" id="0644" class="graf graf--h4 graf-after--p">Camada de apresentação: a UI</h4><p name="6307" id="6307" class="graf graf--p graf-after--h4">A UI é, particularmente, complexa de ser realizada. Para entender por que é complicado, vamos comparar dois sistemas populares: Linux e Windows. Ambos os sistemas rodam em PCs. Abrir uma janela no Windows exige que você consuma um loop de eventos, crie a janela com um system call específico e faça a captura de eventos para absolutamente tudo: redesenhar a janela, movimentá-la na tela, redimensioná-la, etc. No linux não é muito diferente. O que muda é que você não faz <em class="markup--em markup--p-em">system calls</em> no linux: você comunica-se com o XWindow Server. O legal do linux é que o XWindow Server não precisa estar na mesma máquina. Ele pode estar na rede.</p><p name="4438" id="4438" class="graf graf--p graf-after--p">Até a apresentação dos menus é diferente. No Windows e no Linux, o menu faz parte da janela. No macOS o menu não está na janela, mas é um menu apresentado no topo da tela.</p><p name="97b7" id="97b7" class="graf graf--p graf-after--p">Consegue imaginar o quanto é difícil compatibilizar todas essas diferenças num runtime só? Agora imagine sistemas que não usam o mouse, mas usam touch screen e são orientados a gestos. Percebe a dificuldade?</p><h4 name="3c21" id="3c21" class="graf graf--h4 graf-after--p">Runtime, salve-me!</h4><p name="6929" id="6929" class="graf graf--p graf-after--h4">É curioso como a tecnologia anda. Anos atrás havia a discussão entre linguagens interpretadas e compiladas no Windows: como as linguagens compiladas eram mais rápidas. Haviam diversas linguagens que dependiam de runtimes: Centura, Power Builder e mesmo o Visual Basic. Naquela época as plataformas eram mais simples e o software multi-plataforma dependiam de runtimes menos complexos.</p><p name="eb7f" id="eb7f" class="graf graf--p graf-after--p">Hoje, com diversas plataformas no mercado, escrever software multi-plataforma tornou-se uma tarefa que só é possível por que os runtimes tornaram-se bastante sofisticados. Porém, manter os runtimes é uma tarefa que não é mais possivel ser feita por um punhadinho de programadores apaixonados. É necessária muita coordenação, muita gente e muitas disciplinas diferentes.</p><p name="f54a" id="f54a" class="graf graf--p graf-after--p">Com a populalização das linguagens interpretadas, de novo, o software multi-plataforma tornou-se, na verdade, um grande runtime com uma linguagem enfiada dentro. Basta portar o runtime para outra plataforma que todo o software continua funcionando. Mas isto tem um preço.</p><p name="15c9" id="15c9" class="graf graf--p graf-after--p">As linguagens interpretadas precisam de um intérprete para converter o bytecode em execução. E este intérprete costuma consumir muito mais recursos do que uma linguagem que é dita hoje em dia como <em class="markup--em markup--p-em">nativa.</em> A linguagem <em class="markup--em markup--p-em">nativa</em> é compilada e gera um executável de verdade, o que economiza, sobremaneira, o uso de recursos.</p><h4 name="a1d3" id="a1d3" class="graf graf--h4 graf-after--p">Cross-compilers</h4><p name="063d" id="063d" class="graf graf--p graf-after--h4">Agora está na moda, também, os <em class="markup--em markup--p-em">cross compilers</em>. Trata-se de tecnologia muito antiga. Na verdade, o cross compiler compila o seu código para outra plataforma. Ou seja, você compila no seu PC código que vai rodar num processador ARM.</p><p name="7539" id="7539" class="graf graf--p graf-after--p">A Apple faz isso com o seu LLVM, assemblers e linkers. A Microsoft faz isso há anos, desde os tempos do Windows CE. Existem também os compiladores que convertem uma linguagem em outra antes de efetivamente gerarem os executáveis finais, os <em class="markup--em markup--p-em">transpilers</em>.</p><p name="a718" id="a718" class="graf graf--p graf-after--p">Esta tecnologia tira da equação o custoso intérprete, entregando um executável final. O que vai variar é como este executável final usa os frameworks ditos <em class="markup--em markup--p-em">nativos</em>. Em alguns casos, adicionam camadas extras, em outros usam os frameworks diretamente.</p><p name="4b9a" id="4b9a" class="graf graf--p graf-after--p">Só para fazer um parêntese, o framework &quot;nativo&quot; muitas vezes é apenas uma camada de compatibilidade entre o sistema operacional e a sua aplicação. Em particular a Apple usa isso com bastante sucesso em suas aplicações. Quando você precisa comunicar-se com a rede, você não precisa abrir um <em class="markup--em markup--p-em">socket,</em> mas usa o URL Loading System que é uma camada de abstração bem interessante. Vale lembrar que o próprio BSD <em class="markup--em markup--p-em">Socket</em> já é uma camada de abstração em cima do enlace de rede — tanto é que é possível comunicar-se dentro da mesma máquina com <em class="markup--em markup--p-em">sockets</em> unix, que nada tem haver com TCP/IP ou rede.</p><h4 name="1275" id="1275" class="graf graf--h4 graf-after--p">Abraçar ou não a multi-plataforma?</h4><p name="e8f4" id="e8f4" class="graf graf--p graf-after--h4">Tudo tem seu uso. Tudo tem seu cenário ótimo. Encarar os <em class="markup--em markup--p-em">runtimes</em> atuais que entregam software em várias plataformas como tábua de salvação para todos os problemas da humanidade e de uma burrice monumental. Existem diversos cenários nos quais os softwares multi-plataforma não tem alternativa a não ser usar o que há de melhor na plataforma de forma totalmente específica.</p><p name="7a2b" id="7a2b" class="graf graf--p graf-after--p">Sempre que a especificidade de uma plataforma faz a diferença na experiência do usuário, o software multi-plataforma deixa de ser interessante e torna-se, na verdade, uma peça de engenharia de foguete.</p><p name="b58f" id="b58f" class="graf graf--p graf-after--p graf--trailing">Outro ponto importante: sempre que há limitações em determinada plataforma, tentar forçar os limites com <em class="markup--em markup--p-em">runtimes </em>torna o custo de desenvolvimento do seu software astronômico ao longo do tempo. Quando você assustar, se verá desenvolvendo código totalmente nativo para cada plataforma, lutando para integrá-lo ao seu runtime.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/73c7d9d85e12"><time class="dt-published" datetime="2017-12-09T20:58:29.979Z">December 9, 2017</time></a>.</p><p><a href="https://medium.com/@ronaldolima/a-dificuldade-da-multi-plataforma-73c7d9d85e12" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>