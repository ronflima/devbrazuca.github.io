<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Perdendo o medo de C</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Perdendo o medo de C</h1>
</header>
<section data-field="subtitle" class="p-summary">
A linguagem é bem mais simples do que parece.
</section>
<section data-field="body" class="e-content">
<section name="83a3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="37ea" id="37ea" class="graf graf--h3 graf--leading graf--title">Perdendo o medo de C</h3><p name="32d3" id="32d3" class="graf graf--p graf-after--h3">A linguagem é bem mais simples do que parece.</p><figure name="1e46" id="1e46" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dVPIbOTyNcv6iwLmK8JWLA.png" data-width="2000" data-height="2126" src="https://cdn-images-1.medium.com/max/800/1*dVPIbOTyNcv6iwLmK8JWLA.png"></figure><p name="f205" id="f205" class="graf graf--p graf-after--figure">Ontem estive na excelente palestra de Mariana Mioto para o Women Tech Makers em Ribeirão Preto e algo que ela disse na palestra acendeu uma luzinha que eu precisava transformar em palavras — neste caso, em um artigo. E este artigo tinha que ser sobre a linguagem C.</p><p name="a524" id="a524" class="graf graf--p graf-after--p">C é uma linguagem antiga. Nasceu em 1970 na Bell Labs. Veio sendo padronizada ao longo dos anos e o último padrão da linguagem data de 2011. De todas as linguagens de programação, por que C é tão especial, e por que é tão amaldiçoada?</p><p name="628e" id="628e" class="graf graf--p graf-after--p">Bem, antes de responder a estas questões, queria fazer uma pequena apresentação. Este é um artigo de uma série sobre a linguagem C. A intenção é tirar o trauma de quem foi maltratado pelo professor de programação na faculdade e servir de base para que as pessoas aprendam a linguagem de forma mais simples.</p><h4 name="eb4c" id="eb4c" class="graf graf--h4 graf-after--p">Por que C?</h4><p name="53a7" id="53a7" class="graf graf--p graf-after--h4">C é uma linguagem antiga mas não menos cheia de conceitos fantásticos. Grande parte das linguagens de programação atuais se basearam na sintaxe limpa e simples de C. Por que você deveria aprender C? A grande maioria dos sistemas operacionais é escrita em C. Os intérpretes das principais linguagens de programação são escritos em C. As grande maioria das linguagens interpretadas pode ser ampliada com módulos escritos em C. Para programar software embarcado, C é uma das melhores opções justamente pelo seu pequeniníssimo <em class="markup--em markup--p-em">footprint</em>.</p><p name="93f4" id="93f4" class="graf graf--p graf-after--p">Eu poderia passar o texto todo discorrendo sobre o por que você deveria aprender C. Ao invés disso, prefiro resumir em uma frase: aprender C te dará uma excelente base para aprender qualquer outra linguagem de programação.</p><p name="3c6d" id="3c6d" class="graf graf--p graf-after--p">Porém, é preciso tirar da cabeça a ideia de que C é difícil. Portanto, a partir deste ponto, esqueça tudo o que aprendeu sobre C e vamos começar de novo.</p><h4 name="427b" id="427b" class="graf graf--h4 graf-after--p">O compilador</h4><p name="82df" id="82df" class="graf graf--p graf-after--h4">Antes de irmos às vias de fato é preciso falar um pouco sobre como funciona o processo de compilação de um programa escrito em C. Você pode pensar: o que isso tem haver com a linguagem? A resposta é: tudo. Existe um negócio chamado de <em class="markup--em markup--p-em">diretiva de compilação</em> que muda como o seu programa será compilado. Esse negócio faz parte da linguagem. Assim, é importante saber como o seu programa compila. Alguns conceitos vou deixar um pouco no ar por enquanto para voltar mais tarde.</p><p name="d507" id="d507" class="graf graf--p graf-after--p">Para entender como a coisa funciona, vamos começar com o famoso <em class="markup--em markup--p-em">Hello World:</em></p><pre name="6e0d" id="6e0d" class="graf graf--pre graf-after--p">#include &lt;stdio.h&gt;</pre><pre name="edf7" id="edf7" class="graf graf--pre graf-after--pre">int main(void) {<br>    printf(&quot;Hello, World!\n&quot;);<br>    return 0;<br>}</pre><p name="be66" id="be66" class="graf graf--p graf-after--pre">Vamos salvar isto num arquivo <em class="markup--em markup--p-em">hello.c</em>. Para gerar o executável <em class="markup--em markup--p-em">hello</em>, considerando-se que estamos usando um compilador C no unix ou linux, é preciso executar a seguinte linha de comando:</p><pre name="454a" id="454a" class="graf graf--pre graf-after--p">gcc hello.c -o hello</pre><p name="bb24" id="bb24" class="graf graf--p graf-after--pre">Este comando vai fazer o seguinte:</p><p name="5869" id="5869" class="graf graf--p graf-after--p">A primeira coisa é o pré-processador. O pré-processador dá uma lida no seu arquivo à procura de macros e diretivas. No nosso exemplo, o comando de pré-processamento <code class="markup--code markup--p-code">#include</code> fará com que o pré-processador leia o conteúdo do arquivo <code class="markup--code markup--p-code">stdio.h</code> e o pré-processe também, gerando uma salada russa. Para ver o que o pré-processador gera, use a seguinte linha de comando:</p><pre name="b30a" id="b30a" class="graf graf--pre graf-after--p">gcc -E hello.c</pre><p name="fcd7" id="fcd7" class="graf graf--p graf-after--pre">Isso vai gerar uma saída monstruosa na sua tela. Essa confusão toda é chamada de <em class="markup--em markup--p-em">unidade de tradução</em>. Depois de finalizado o pré-processamento o próximo passo será a verificação sintática do seu código.</p><p name="b1e6" id="b1e6" class="graf graf--p graf-after--p">Nesta fase, a sua unidade de tradução é verificada contra erros de sintaxe. O compilador verificará se os tipos nas expressões são adequados, se é possível realizar promoções ou demoções de tipos, dependendo das expressões. Chamadas de função são computadas quanto aos tipos dos parâmetros e por aí vai.</p><p name="1f06" id="1f06" class="graf graf--p graf-after--p">A próxima etapa é a <em class="markup--em markup--p-em">montagem</em>. A montagem consiste em converter a sua unidade de tradução para linguagem de máquina criando-se, assim, o <em class="markup--em markup--p-em">objeto relocável</em>. Normalmente o objeto relocável é um arquivo com extensão <em class="markup--em markup--p-em">.o</em>. Este arquivo contém código de máquina, porém é preciso ainda alguma coisa para termos o executável final: a resolução dos símbolos pendentes.</p><p name="3d5f" id="3d5f" class="graf graf--p graf-after--p">A função <em class="markup--em markup--p-em">printf</em> não foi você quem escreveu. Ela faz parte da biblioteca padrão da linguagem. O <em class="markup--em markup--p-em">protótipo </em>dela está no arquivo de cabeçalho <code class="markup--code markup--p-code">stdio.h</code>. O protótipo é, basicamente, a <em class="markup--em markup--p-em">assinatura</em> da função. Isto é usado para permitir a verificação de tipos dos parâmetros e do retorno da função.</p><p name="bf5e" id="bf5e" class="graf graf--p graf-after--p">Bem, o problema que o compilador tem de resolver agora é: onde está o código da função <em class="markup--em markup--p-em">printf</em>? Este processo é chamado de <em class="markup--em markup--p-em">ligação</em>, ou seja, o compilador chamará o <em class="markup--em markup--p-em">ligador</em> que procurará nas bibliotecas binárias onde está o código da função, trazendo este código para o seu executável final. Normalmente a biblioteca de rotinas da linguagem C é uma biblioteca dinâmica, ou seja, o seu executável não terá o código da função <em class="markup--em markup--p-em">printf</em> enfiado dentro dele, mas uma referência à biblioteca padrão da linguagem, que será carregada em memória quando seu executável for chamado.</p><p name="cc7e" id="cc7e" class="graf graf--p graf-after--p">Bem, este é todo o processo da compilação, visto de maneira bem simplificada. A ideia aqui é entender que é possível, do seu código, enviar comandos ao compilador através de <em class="markup--em markup--p-em">diretivas de pré-processamento</em>. Isto é particularmente útil quando se está criando código multi-plataforma no intuito de isolar trechos específicos.</p><h4 name="5e9c" id="5e9c" class="graf graf--h4 graf-after--p">A estrutura de um programa</h4><p name="2788" id="2788" class="graf graf--p graf-after--h4">Bem, o nosso exemplinho dá uma imagem bem simplificada de como é um programa escrito em C. Ali temos o seguinte:</p><ul class="postList"><li name="3f3f" id="3f3f" class="graf graf--li graf-after--p">Todo programa em C tem como ponto de entrada uma função notável chamada <em class="markup--em markup--li-em">main</em>. Não importa onde você escreva a função <em class="markup--em markup--li-em">main</em>. Pode ser em qualquer arquivo que componha o seu programa. É ela quem vai executar primeiro.</li><li name="f0a8" id="f0a8" class="graf graf--li graf-after--li">Todo programa C pode ter uma ou mais diretivas <em class="markup--em markup--li-em">include</em>. Esta diretiva inclui arquivos na unidade de tradução. Aqui cabe um parêntesis: a diretiva <em class="markup--em markup--li-em">include</em> precisa ser usada para incluir arquivos de <strong class="markup--strong markup--li-strong">cabeçalho<em class="markup--em markup--li-em">, </em></strong>com extensão <em class="markup--em markup--li-em">.h</em>. Arquivo de cabeçalho, conforme veremos mais adiante, é para <strong class="markup--strong markup--li-strong">declarar</strong> e não <strong class="markup--strong markup--li-strong">definir</strong>. Existe uma <strong class="markup--strong markup--li-strong">grande</strong> diferença entre estes dois termos.</li><li name="a595" id="a595" class="graf graf--li graf-after--li">Um programa C pode ter muito mais do que só um arquivo. Isso pode parecer meio óbvio. Mas muita gente, quando está iniciando, escreve o programa todo num arquivo sacola.</li></ul><p name="e9f2" id="e9f2" class="graf graf--p graf-after--li">A função <em class="markup--em markup--p-em">main</em> é a primeira função <em class="markup--em markup--p-em">do seu código</em> a ser chamada, mas não é a primeira função a ser executada no seu programa. Antes da função <em class="markup--em markup--p-em">main</em> existe uma função gerada pelo compilador chamada de <em class="markup--em markup--p-em">loader</em>. O <em class="markup--em markup--p-em">loader</em>, ou carregador, realiza uma série de pequenas tarefas, como preparar a carga do seu programa, ler e contar os argumentos de linha de comando e obter as variáveis de ambiente no momento em que seu programa entra em execução.</p><p name="16eb" id="16eb" class="graf graf--p graf-after--p">O carregador ainda pode definir <em class="markup--em markup--p-em">handlers</em> padrão para sinais e definir algumas características do processo recém criado para executar o seu programa. O que o carregador faz, na verdade, pouco importa. Você não tem o que fazer. Ele vai fazer sem você pedir. Fica aqui como uma informação adicional.</p><h4 name="c05a" id="c05a" class="graf graf--h4 graf-after--p">Procedural</h4><p name="24f1" id="24f1" class="graf graf--p graf-after--h4">Acostumado com programação orientada ao objeto? Bom, C é procedural. Não existem objetos em C. Isto não significa que não seja possível programar orientado ao objeto em C. Em 2003 eu comecei um projeto com um amigo chamado de <a href="https://github.com/ronflima/feijuca" data-href="https://github.com/ronflima/feijuca" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Feijuca</a>. A biblioteca começou no Source Forge e há alguns anos atrás migrei-a para o Github. Ela é integralmente escrita em C padrão. E é orientada ao objeto.</p><p name="2208" id="2208" class="graf graf--p graf-after--p">Se você tiver a curiosidade de ler o código da biblioteca verá um amontoado de funções. E é assim que tem de ser: C trabalha com funções e ponto final. Portanto, não há como chamar uma mensagem de um objeto. A coisa é meio inversa: você chama uma função passando o objeto como parâmetro. A função é quem altera o estado do objeto.</p><p name="d6c1" id="d6c1" class="graf graf--p graf-after--p">No nosso exemplo, temos apenas a função <em class="markup--em markup--p-em">main</em>. Porém, chamamos a função <em class="markup--em markup--p-em">printf</em>. E é assim que a coisa funciona: uma função que chama outra função e assim segue a coisa.</p><h4 name="aa74" id="aa74" class="graf graf--h4 graf-after--p">Proximidade com a máquina</h4><p name="d3fb" id="d3fb" class="graf graf--p graf-after--h4">Apesar de não ficar muito explícito no código que escrevemos, C é uma linguagem muito próxima da máquina. A função <em class="markup--em markup--p-em">main </em>esconde o carregador. O carregador é altamente depende de plataforma. A ideia por trás de C é ser uma linguagem altamente portável.</p><p name="ebea" id="ebea" class="graf graf--p graf-after--p">Uma das coisas que assustam quem está aprendendo C são os ponteiros, ou variáveis de ponteiro. É um conceito simples, porém normalmente é explicado nos cursos de programação como algo muito abstrato sendo que, na verdade, o ponteiro não tem nada de abstrato: é meramente um endereço de memória.</p><p name="9f79" id="9f79" class="graf graf--p graf-after--p">C permite que você leia cada bit de um endereço arbitrário de memória. Também permite que você mude uma informação bit a bit. Mas isso é bem mais simples do que parece.</p><h4 name="6bff" id="6bff" class="graf graf--h4 graf-after--p">Ferramentas</h4><p name="72b8" id="72b8" class="graf graf--p graf-after--h4">Como eu disse, todo programa em C pode ter uma cacetada de arquivos. Cada arquivo com várias funções, declarações de tipos, definições das mais variadas coisas. A questão é: como é que eu junto esse tanto de tralha e transformo num programa que eu possa executar?</p><p name="1c80" id="1c80" class="graf graf--p graf-after--p">Compilar manualmente um sistema escrito em C é pedir para morrer doido. Existem ferramentas para isto. A ferramenta mais tradicional é o <em class="markup--em markup--p-em">make</em> e seus <em class="markup--em markup--p-em">makefiles</em>. Esta ferramenta faz <em class="markup--em markup--p-em">tracking</em> de dependência entre os arquivos que compõem seu software no intuito de compilar somente aquilo que ainda não foi compilado ou somente aquilo que foi mudado, no intuito de otimizar o processo de criação do seu executável.</p><p name="f906" id="f906" class="graf graf--p graf-after--p">Para programas em C eu gosto dos <em class="markup--em markup--p-em">autotools</em>, um conjunto de ferramentas do projeto GNU que visam criar scripts e um ambiente de compilação facilmente portável. Mas nada impede que você use ferramentas mais atuais como <em class="markup--em markup--p-em">maven</em>, <em class="markup--em markup--p-em">ant</em> ou até mesmo os task runners como Grunt, Cake, Gulp e outros. Você pode entender o <em class="markup--em markup--p-em">make</em> como um task runner primitivo. E é isso que o <em class="markup--em markup--p-em">make </em>é<em class="markup--em markup--p-em">. </em>Já usei o make para fazer coisas como deployment, instalação de patches em databases e mais uma série de coisas além de simplesmente gerar um executável.</p><p name="2247" id="2247" class="graf graf--p graf-after--p">Eu sou da política de que você precisa usar aquilo que você conhece. Se você conhece o Grunt, use-o. Vai ser mais rápido do que aprender a usar o <em class="markup--em markup--p-em">autotools</em>. Porém, se você quiser escrever algo em C que possa ser distribuído para a comunidade de software livre, <em class="markup--em markup--p-em">autotools </em>não é uma opção: é uma obrigação.</p><h4 name="6928" id="6928" class="graf graf--h4 graf-after--p">Chega!</h4><p name="3be8" id="3be8" class="graf graf--p graf-after--h4 graf--trailing">Bom, eu não gosto de artigos muito grandes. Vamos parar por aqui. Como minha intenção é escrever uma série de artigos, vamos deixar para o próximo falar mais em código e menos em teoria. Achei por bem iniciar com uma carga teórica sobre alguns assuntos que considero imprescindíveis no entendimento da linguagem e seus acessórios.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/4ea1415fb8a0"><time class="dt-published" datetime="2017-03-04T00:37:01.947Z">March 4, 2017</time></a>.</p><p><a href="https://medium.com/@ronaldolima/perdendo-o-medo-de-c-4ea1415fb8a0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>