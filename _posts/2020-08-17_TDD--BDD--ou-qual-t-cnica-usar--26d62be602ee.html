<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>TDD, BDD, ou qual técnica usar?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">TDD, BDD, ou qual técnica usar?</h1>
</header>
<section data-field="subtitle" class="p-summary">
As primeiras coisas primeiro!
</section>
<section data-field="body" class="e-content">
<section name="0d93" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e997" id="e997" class="graf graf--h3 graf--leading graf--title">TDD, BDD, ou qual técnica usar?</h3><h4 name="3c83" id="3c83" class="graf graf--h4 graf-after--h3 graf--subtitle">As primeiras coisas primeiro!</h4><figure name="d470" id="d470" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*5FjiEW3V-S6C4ZLNDl5LGA.jpeg" data-width="1280" data-height="959" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*5FjiEW3V-S6C4ZLNDl5LGA.jpeg"><figcaption class="imageCaption">Photo by <a href="https://www.pexels.com/@kevin-ku-92347?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" data-href="https://www.pexels.com/@kevin-ku-92347?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Kevin Ku</a> from <a href="https://www.pexels.com/photo/coding-computer-data-depth-of-field-577585/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" data-href="https://www.pexels.com/photo/coding-computer-data-depth-of-field-577585/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Pexels</a></figcaption></figure><p name="2e24" id="2e24" class="graf graf--p graf-after--figure">Outro dia vi um colega CTO defendendo efusivamente o aprendizado do TDD no Linkedin. Bom, antes de começar é bom que você entenda: eu não tenho absolutamente nada contra TDD ou BDD. Na verdade, defendo ambos. Porém, este artigo trata de algo muito mais rudimentar: a capacitação dos developers.</p><h4 name="9a1d" id="9a1d" class="graf graf--h4 graf-after--p">O básico antes</h4><p name="b25d" id="b25d" class="graf graf--p graf-after--h4">Saber uma linguagem de programação não faz de você um programador. Eu já escrevi sobre isso diversas vezes aqui no meu blog. Não é por que você sabe uma linguagem de programação que você é um programador. Na verdade, o conhecimento sobre uma determinada linguagem é a última coisa que você deveria procurar. Existe muito mais coisa importante no meio do caminho.</p><p name="1440" id="1440" class="graf graf--p graf-after--p">Por exemplo, vários programadores desconhecem o modelo relacional. Veja, modelo relacional, não banco de dados relacional. Há uma grande diferença na abordagem. Poucos sabem fazer um DER para analisar e modelar um problema. O conhecimento das formas normais também anda desaparecendo. Falar na primeira forma normal é quase como declamar Camões em Sânscrito.</p><p name="efd4" id="efd4" class="graf graf--p graf-after--p">Antes de sair correndo atrás de uma linguagem de programação, é muito mais importante entender as abstrações. Como estruturar a informação, como criar modelos que expliquem um determinado processo de negócio? Vários programadores não fazem a mais remota ideia de como fazer isso, demonstrando um gap que vejo aumentar-se todos os dias em detrimento do conhecimento de alguma tecnologia específica.</p><p name="1e67" id="1e67" class="graf graf--p graf-after--p">Vejo muita gente que conhece, por exemplo, AWS S2, mas não faz ideia de como projetar um sistema desacoplado, multiprocessado e multi-camadas, este último um conceito que esteve muito em voga na virada do Século XX com seus monitores de transação, application brokers, e por aí vai.</p><h4 name="3202" id="3202" class="graf graf--h4 graf-after--p">Você sabe programar orientado ao objeto?</h4><p name="5ea7" id="5ea7" class="graf graf--p graf-after--h4">A Programação Orientada ao Objeto, por exemplo, é algo fantástico para demonstrar o quanto há um gap de conhecimento nos developers. Você seria capaz de implementar uma biblioteca totalmente orientada ao objeto em C? Veja, não estou falando de C++, mas C. É possível fazer isso?</p><p name="8828" id="8828" class="graf graf--p graf-after--p">Sim, é possível. <a href="https://github.com/ronflima/feijuca" data-href="https://github.com/ronflima/feijuca" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">A biblioteca Feijuca</a>, que comecei a escrever em 2003 com um grande amigo, é um claro exemplo: totalmente orientada ao objeto. Programação Orientada ao Objeto é um <em class="markup--em markup--p-em">paradigma</em>, ou seja, um princípio e não uma forma sintática ou semântica de programar. Linguagens como C++, Java, Smalltalk e outras demonstram sintatica e semanticamente como fazê-lo. C, por outro lado, não permite descrever isso desta forma, mas mesmo assim é totalmente possível usar o paradigma.</p><p name="c78d" id="c78d" class="graf graf--p graf-after--p">A biblioteca Feijuca leva em conta o paradigma orientado ao objeto: encapsulamento, herança, análise centrada na informação. Porém, ao ler o código você verá apenas C sem frescura. A abstração vale. Há construtores, destrutores, métodos. Porém, todos são funções que operam um objeto de dados opaco, uma struct. Por que? Por que C não suporta o paradigma de maneira sintática. Mas nada impede que o princípio seja usado.</p><p name="ad32" id="ad32" class="graf graf--p graf-after--p">Quando se fala na POO, muita gente não entende o que é transição de estados, encapsulamento, acoplamento — princípios que são básicos e que servem para qualquer linguagem de programação.</p><h4 name="eaf0" id="eaf0" class="graf graf--h4 graf-after--p">Gaps</h4><p name="4202" id="4202" class="graf graf--p graf-after--h4">Não estou aqui para vangloriar-me de uma biblioteca que escrevi há anos, mas para apontar que há um gap de conhecimento nos developers que, na minha humilde opinião, deveria ser considerado como algo grave.</p><p name="c981" id="c981" class="graf graf--p graf-after--p">Com o passar dos anos, a responsabilidade em cima dos developers aumentou consideravelmente. Duas funções tornaram-se uma só. Antes, quem projetava o sistema era o Analista de Sistemas. Sua função era basicamente entender e modelar o problema, oferecendo uma solução matemática que cobrisse os cenários avaliados do problema em exame.</p><p name="0567" id="0567" class="graf graf--p graf-after--p">Somente depois entrava em cena o programador, que nada mais era que um escritor de código. Era o trabalho do programador traduzir o modelo criado pelo analista em código executável.</p><p name="d477" id="d477" class="graf graf--p graf-after--p">O que mudou nos últimos anos é que o desenvolvedor é o antigo <em class="markup--em markup--p-em">analista-programador</em>, ou seja, uma junção das duas funções em uma. Porém, os desenvolvedores focam-se muito mais nas linguagens de programação do que nas abstrações. O efeito disso são modelos ineficientes e ineficazes. A máxima “aumenta o tamanho da VM” nunca foi tão usada como nos últimos tempos. Este é um efeito colateral da ineficiência das soluções como um todo: cada vez mais poder de processamento e necessário para que o software execute.</p><h4 name="0fa0" id="0fa0" class="graf graf--h4 graf-after--p">Estude, sempre!</h4><p name="efa2" id="efa2" class="graf graf--p graf-after--h4">Nós temos uma profissão que nos obriga a estudar sempre. Afinal, sempre aparece algo novo para olhar. Mas não é apenas o “novo” que precisamos estudar. É preciso, também, olhar as fundações, entender como a análise e o modelamento funcionam, entender que estas são ferramentas fundamentais para escrever código.</p><p name="1d56" id="1d56" class="graf graf--p graf-after--p">Ao longo dos anos eu diminui o tempo que uso para escrever código. Eu diria que hoje eu gasto 10% do meu tempo escrevendo código efetivamente. Os outros 90% são estudando o problema, criando modelos, testando estes modelos, avaliando hipóteses. Uma vez que o problema é conhecido e está resolvido, a escrita de código é quase trivial. Afinal, com um modelo pronto, torná-lo uma realidade é bem mais simples do que parece.</p><p name="1d3f" id="1d3f" class="graf graf--p graf-after--p">Grande parte do esforço de desenvolvimento atualmente é gasto modelando e escrevendo código ao mesmo tempo. O resultado é um modelo final capenga, cheio de remendos. Como o foco está no código, e não no princípio que levou à escrita do código, o efeito é bem conhecido: muitos bugs, muito retrabalho. Se você usa TDD, certamente seus cenários de testes são complexos e quase um sistema à parte. Mas isto é por que o modelo não foi bem projetado, não foi bem validado.</p><p name="6a0b" id="6a0b" class="graf graf--p graf-after--p">Costumo dizer que a escrita de código é a última coisa que se deve fazer. E não é para menos: como você quer construir uma ponte sem conhecer o mínimo sobre arquitetura, engenharia e o local onde a ponte será feita? Por que nós, programadores, queremos fazer diferente e sair escrevendo código tão logo a tarefa cai no nosso colo?</p><p name="8566" id="8566" class="graf graf--p graf-after--p graf--trailing">Para refletir…</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/26d62be602ee"><time class="dt-published" datetime="2020-08-17T11:39:39.472Z">August 17, 2020</time></a>.</p><p><a href="https://medium.com/@ronaldolima/tdd-bdd-ou-qual-t%C3%A9cnica-usar-26d62be602ee" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>