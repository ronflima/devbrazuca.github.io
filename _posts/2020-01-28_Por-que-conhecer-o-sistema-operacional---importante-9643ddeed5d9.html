<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Por que conhecer o sistema operacional é importante</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Por que conhecer o sistema operacional é importante</h1>
</header>
<section data-field="subtitle" class="p-summary">
Isso pode economizar muito dinheiro no seu PaaS predileto
</section>
<section data-field="body" class="e-content">
<section name="514e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="dc6a" id="dc6a" class="graf graf--h3 graf--leading graf--title">Por que conhecer o sistema operacional é importante</h3><h4 name="27ce" id="27ce" class="graf graf--h4 graf-after--h3 graf--subtitle">Isso pode economizar muito dinheiro no seu PaaS predileto</h4><figure name="d158" id="d158" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*pVAm5YOJKZez0bQyPB-sXQ.jpeg" data-width="1280" data-height="1171" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*pVAm5YOJKZez0bQyPB-sXQ.jpeg"></figure><p name="cdb1" id="cdb1" class="graf graf--p graf-after--figure">Uma vez um amigo me perguntou por que é importante saber o que é um system call e por que isso é importante para o desenvolvimento, considerando que hoje os sistemas estão cada vez mais distantes do sistema operacional por conta da enormidade de frameworks e ferramentas de desenvolvimento que existem por aí.</p><p name="1914" id="1914" class="graf graf--p graf-after--p">Mesmo em ambientes interpretados nos quais tudo passa pelo intérprete, é importante saber o que o sistema operacional faz por debaixo dos panos por que isso tem impactos substanciais na forma como você escreve o seu código.</p><h4 name="a18d" id="a18d" class="graf graf--h4 graf-after--p">O meu código roda em um container!</h4><p name="410b" id="410b" class="graf graf--p graf-after--h4">Parabéns! O container no qual roda o seu código usa um sistema operacional. Como você acredita que seu código consegue abrir arquivos, sockets, filas de mensagens ou, ainda, sincronizar threads? Nada disso é oferecido pelo seu container, mas pelo sistema operacional que está dentro do container junto com o seu código.</p><p name="9c0a" id="9c0a" class="graf graf--p graf-after--p">Mesmo em sistemas que hospedam aplicações, como os web apps do Azure ou as aplicações do Heroku, há um sistema operacional provendo uma série de serviços básicos que o seu software utiliza direta ou indiretamente. E mesmo que você utilize um intérprete, este precisa realizar chamadas de sistema para alocar mais memória, abrir arquivos, criar mutexes para sincronismo de threads e por aí vai.</p><p name="3bfe" id="3bfe" class="graf graf--p graf-after--p">Assim, é importante saber quando é que uma instrução pode ocasionar uma chamada de sistema e o motivo é simples: quando isso acontece, o seu software simplesmente é pausado para que a chamada de sistema execute. Ao terminar a chamada de sistema, o processamento do seu software é resumido do ponto onde parou. Isso tem consequências importantes na forma como o seu código precisa ser projetado.</p><h4 name="2adb" id="2adb" class="graf graf--h4 graf-after--p">Paralelo ou assíncrono?</h4><p name="ff4c" id="ff4c" class="graf graf--p graf-after--h4">Existe uma confusão enorme sobre paralelismo e assincronia nos dias de hoje. Estes dois conceitos são substancialmente importantes do ponto-de-vista de projeto de uma aplicação, principalmente aplicações que precisam, necessariamente, de um tempo de resposta ínfimo por restrições impostas pelo projeto.</p><p name="592f" id="592f" class="graf graf--p graf-after--p">A assincronia é efeito das threads em user space, ou co-rotinas: o contexto de execução é trocado sempre que uma operação que realiza o bloqueio do processamento é realizada, dando oportunidade para outra rotina entrar em execução enquanto a rotina original aguarda o retorno do bloqueio. Mas, o que isto quer dizer?</p><p name="c855" id="c855" class="graf graf--p graf-after--p">A thread em user space é uma forma de simular o funcionamento do kernel do sistema operacional na troca de contextos entre threads. A diferença é que toda a gestão da troca de contexto fica por conta do seu código. O que acontece na prática é o seguinte:</p><ul class="postList"><li name="a662" id="a662" class="graf graf--li graf-after--p">Seu código entra em execução</li><li name="ddbe" id="ddbe" class="graf graf--li graf-after--li">Em determinado momento, seu código faz uma chamada que causa um bloqueio da execução — normalmente um system call, ou simplesmente abre mão do processamento (yield é uma palavra reservada normalmente utilizada em diversas linguagens que suportam isto na definição da linguagem)</li><li name="659e" id="659e" class="graf graf--li graf-after--li">Enquanto o seu código aguarda o retorno, a pilha atual é salva e em seu lugar é colocada a pilha de outra rotina que aguarda para executar. Se não há outra pilha salva, uma rotina é disparada em cima de uma pilha vazia.</li><li name="b57a" id="b57a" class="graf graf--li graf-after--li">Quando a chamada de sistema retorna à rotina que estava aguardando, a rotina atual é interrompida, a sua pilha é salva e a pilha da rotina que estava interrompida é restaurada; a execução resume-se do ponto onde parou.</li></ul><p name="c74d" id="c74d" class="graf graf--p graf-after--li">Este princípio, descrito aqui de forma absolutamente simplista, é a famosa <em class="markup--em markup--p-em">troca de contexto</em>. Porém, no caso da thread em user space, isto acontece dentro do processo. A principal vantagem é que a troca de contexto dentro do processo é muito mais eficiente do que a troca de contexto promovida pelo kernel do seu sistema operacional quando é necessário trocar o contexto entre threads distintas. Aqui, tudo ocorre serialmente, dentro da mesma thread. Ou seja, nada é paralelo.</p><p name="2119" id="2119" class="graf graf--p graf-after--p">Entender a diferença entre threads em user space e threads <em class="markup--em markup--p-em">de facto</em> é importante no projeto do seu software: isto muda completamente a forma como você irá projetar a estrutura do seu código. Nas threads em user space, como o processamento é sempre serial, não existem seções críticas. Assim, não há a necessidade de sincronismo entre as diversas rotinas que concorrem pelo tempo gerenciado pelo scheduler.</p><p name="a5a4" id="a5a4" class="graf graf--p graf-after--p">Por outro lado, as threads exigem sincronismo pois o seu software pode ser quebrado de formas inoportunas quando uma thread perde o seu time share dentro de uma seção crítica. O que isso tem a ver com o sistema operacional?</p><h4 name="e2b8" id="e2b8" class="graf graf--h4 graf-after--p">Threads e Processos</h4><p name="1b02" id="1b02" class="graf graf--p graf-after--h4">Tanto as threads quanto os processos são entidades gerenciadas pelo sistema operacional, bem como os elementos de sincronismo: mutexes e semáforos. Qualquer operação feita usando estes elementos implica em uma chamada de sistema. Ou seja, a sua rotina vai solicitar algo ao sistema operacional. Por outro lado, apesar dos system calls, as threads e os processos executam, basicamente, em paralelo em máquinas com vários processadores.</p><p name="b010" id="b010" class="graf graf--p graf-after--p">Isto quer dizer que o throughput de processamento do seu software tende a ser muito superior ao mesmo software escrito de forma serial. No entanto, a programação paralela traz, em si, diversos compromissos e desafios: o código tende a ser bastante complexo. Em uma arquitetura multi-processos, há o footprint do processo, que é muito superior ao de uma thread, e a dificuldade de comunicar-se entre os processos envolvidos. O isolamento entre processos pode ser uma vantagem — o Google Chrome usa uma estrutura multi-processos para evitar o travamento do software, por exemplo.</p><h4 name="17c8" id="17c8" class="graf graf--h4 graf-after--p">Conheça o Sistema Operacional</h4><p name="852c" id="852c" class="graf graf--p graf-after--h4">Todo esse blablablá focou-se em entidades do sistema operacional. Quer paralelismo? Multi-processos. Memória está curta? Multi-threads. Muito I/O no seu sistema? Threads em user space. E é importante entender quais as consequências de cada necessidade pois isso tem implicações no uso do sistema operacional que será quem proverá os serviços básicos para o seu software, independentemente se você faz deploy numa VM, um container ou um serviço de aplicativos.</p><p name="1806" id="1806" class="graf graf--p graf-after--p graf--trailing">Cedo ou tarde alguém vai fazer um system call e entender que isto acontece lhe dá uma visão ampla de como projetar e construir o seu software para atender a demanda de automação que você está atendendo. Este conhecimento permite que você use as premissas certas ao escrever o seu código, além de permitir que você projete de forma melhor a estrutura da sua aplicação, tirando vantagem das características do sistema operacional no qual o seu software vai executar.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/9643ddeed5d9"><time class="dt-published" datetime="2020-01-28T12:00:49.273Z">January 28, 2020</time></a>.</p><p><a href="https://medium.com/@ronaldolima/por-que-conhecer-o-sistema-operacional-%C3%A9-importante-9643ddeed5d9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>