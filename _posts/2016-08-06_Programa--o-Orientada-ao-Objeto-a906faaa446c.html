<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Programação Orientada ao Objeto</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Programação Orientada ao Objeto</h1>
</header>
<section data-field="subtitle" class="p-summary">
Demorei anos para entender que raios era isso. E não é simples assim.
</section>
<section data-field="body" class="e-content">
<section name="50e1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bb96" id="bb96" class="graf graf--h3 graf--leading graf--title">Programação Orientada ao Objeto</h3><h4 name="abb9" id="abb9" class="graf graf--h4 graf-after--h3 graf--subtitle">Demorei anos para entender que raios era isso. E não é simples assim.</h4><figure name="2d84" id="2d84" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*XtnYegzS5oCV0xWGEgNaiQ.jpeg" data-width="5760" data-height="3840" src="https://cdn-images-1.medium.com/max/800/1*XtnYegzS5oCV0xWGEgNaiQ.jpeg"></figure><p name="7ab8" id="7ab8" class="graf graf--p graf-after--figure">Hoje em dia toda nova linguagem de programação é orientada ao objeto. A despeito disso, o que mais vejo é código escrito nessas linguagens que não são orientados ao objeto. Hein!? Como assim?! Como é possível escrever código não orientado ao objeto em uma linguagem orientada ao objeto?</p><p name="7273" id="7273" class="graf graf--p graf-after--p">O paradigma de programação orientada ao objeto é antigo. As ideias nasceram no MIT nos fins de 1950. A primeira linguagem que aprendi orientada ao objeto foi Pascal, mais especificamente Turbo Pascal 5.5, que foi a primeira versão do Pascal da Borland a suportar a POO. De lá para cá muita coisa mudou e a coisa, que já era abstrata, ficou ainda mais abstrata: <em class="markup--em markup--p-em">factories</em>, <em class="markup--em markup--p-em">adapters, mementos, chains of responsibility…</em> Os <em class="markup--em markup--p-em">design patterns</em> trouxeram mais abstração para a POO e hoje em dia a metáfora dos animais já não é boa o suficiente para ensinar POO.</p><p name="7717" id="7717" class="graf graf--p graf-after--p">Por ser algo muito abstrato, a POO é difícil de aprender. Vários conceitos são artificiais e isso torna o aprendizado bastante complicado. O resultado que se vê é isto: muito código não orientado ao objeto escrito em linguagens orientadas ao objeto.</p><p name="daaf" id="daaf" class="graf graf--p graf-after--p">Quer um exemplo? Alguém, algum dia, inventou uma coisa macabra chamada de <em class="markup--em markup--p-em">helper</em>. O conceito foi distorcido e tornou-se uma classe sacola cheia de métodos estáticos. Como não há o menor controle de estado dentro desta classe, a mesma é usada somente para agrupar os métodos dentro de um namespace bem definido. E os métodos, neste contexto, se tornam meramente um amontoado de funções, como na programação procedural.</p><p name="2f14" id="2f14" class="graf graf--p graf-after--p">Ou seja, os métodos estáticos são, na verdade, uma forma usada por programadores menos experientes para colocar código procedural dentro dos sistemas que deveriam ser orientados ao objeto. O resultado final é um código que parece um frankenstein: classes, objetos e procedures.</p><p name="e476" id="e476" class="graf graf--p graf-after--p">Outro indicador de que seu código não é orientado ao objeto é o uso indiscriminado de <em class="markup--em markup--p-em">design patterns, </em>principalmente do <em class="markup--em markup--p-em">singleton</em>. Por ser fácil de implementar, o singleton é usado indiscriminadamente. O resultado é um código final altamente acoplado à uma variável global. Sim, meus amigos, o singleton é a forma mais simples de conseguir-se uma variável global em qualquer linguagem de programação orientada ao objeto, inclusive no java.</p><p name="3a4b" id="3a4b" class="graf graf--p graf-after--p">Os objetos tem ciclos de vida bem determinados. Mantém seus estados e permitem que agentes externos mudem seus estados internos através de métodos. Se você não programa desse jeito você está, na verdade, escrevendo código procedural, ou seja, código que dá importância primeiro ao que precisa ser feito e depois aos dados.</p><p name="a920" id="a920" class="graf graf--p graf-after--p">A POO foca os dados e depois os que se pode fazer com eles. O ciclo de vida dos objetos é bem definido e a forma de controlar os estados internos também. Na programação procedural os estados são mantidos fora dos dados e as operações que transformam os dados são as mesmas que mantém os estados dos dados em processamento.</p><h4 name="732f" id="732f" class="graf graf--h4 graf-after--p">Projete antes, escreva depois</h4><p name="7753" id="7753" class="graf graf--p graf-after--h4">Não se escreve código orientado ao objeto sem antes projetá-lo. Você precisa ter um modelo bem definido para começar a escrever código. Sair escrevendo código sem antes projetar o modelo terá os seguintes efeitos:</p><ul class="postList"><li name="7597" id="7597" class="graf graf--li graf-after--p">seu código será altamente acoplado. Qualquer generalização e tentativa de modularizar o código será frustrada por conta do alto acoplamento;</li><li name="41ca" id="41ca" class="graf graf--li graf-after--li">seu modelo de dados será ineficiente, mesmo sendo eficaz. Como você escreveu o código sem projetá-lo antes, você terá em suas mãos um grafo de objetos difícil de manter, possivelmente cheio de classes desnecessárias e redundantes;</li><li name="93b9" id="93b9" class="graf graf--li graf-after--li">seu modelo terá classes <em class="markup--em markup--li-em">sacola</em>, verdadeiros elefantes cheios de métodos não relacionados. As classes sacola são um exemplo clássico de programação procedural em um ambiente orientado ao objeto.</li></ul><h4 name="48c8" id="48c8" class="graf graf--h4 graf-after--li">POO não é ágil</h4><p name="94a3" id="94a3" class="graf graf--p graf-after--h4">Não dá para escrever código orientado ao objeto sem parar para projetar antes. Quando o paradigma foi inventado, o que havia no mercado era o modelo <em class="markup--em markup--p-em">waterfall</em>. Todo mundo sabe que o modelo de desenvolvimento <em class="markup--em markup--p-em">waterfall </em>é completamente falho: ele parte da suposição que todo o conhecimento do projeto está disponível no início do projeto.</p><p name="205a" id="205a" class="graf graf--p graf-after--p">Portanto, tentar programar orientado ao objeto sem ter em mente que a POO parte do mesmo princípio é pedir para dar merda. Se você usa um modelo ágil de implementação, como Scrum ou XP, é preciso ter em mente que a cada <em class="markup--em markup--p-em">sprint</em> você terá de reservar um tempinho para projetar o seu grafo de objetos no intuito de projetar um conjunto de classes que seja não só eficaz como também eficiente para resolver seu problema.</p><p name="5af3" id="5af3" class="graf graf--p graf-after--p graf--trailing">Sim, é possível usar a POO em projetos ágeis. O que não dá para fazer é achar que a linguagem orientada ao objeto que você usa é ágil. Não é, desculpe. Mas não é difícil adaptá-la para ser ágil. Ao trabalhar de forma bem modular, com responsabilidades bem definidas, é possível criar um modelo que cresça de maneira ágil sem, no entanto, criar um frankenstein de código.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/a906faaa446c"><time class="dt-published" datetime="2016-08-06T13:08:31.401Z">August 6, 2016</time></a>.</p><p><a href="https://medium.com/@ronaldolima/programa%C3%A7%C3%A3o-orientada-ao-objeto-a906faaa446c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>