<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Shared Libraries: o que raios é isso?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Shared Libraries: o que raios é isso?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Entenda o que são e como funcionam
</section>
<section data-field="body" class="e-content">
<section name="37ed" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4ece" id="4ece" class="graf graf--h3 graf--leading graf--title">Shared Libraries: o que raios é isso?</h3><h4 name="8c0b" id="8c0b" class="graf graf--h4 graf-after--h3 graf--subtitle">Entenda o que são e como funcionam</h4></div><div class="section-inner sectionLayout--fullWidth"><figure name="9778" id="9778" class="graf graf--figure graf--layoutFillWidth graf-after--h4"><img class="graf-image" data-image-id="1*o1-FXMbTb6yT14bM9EjxmA.jpeg" data-width="2048" data-height="777" src="https://cdn-images-1.medium.com/max/2560/1*o1-FXMbTb6yT14bM9EjxmA.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><h4 name="f60a" id="f60a" class="graf graf--h4 graf-after--figure">Definições</h4><p name="b4f9" id="b4f9" class="graf graf--p graf-after--h4">Vamos começar o artigo definindo o que diabos é uma <em class="markup--em markup--p-em">shared library</em>. Basicamente é um conjunto de rotinas que podem ser usadas por diversos executáveis distintos. O que diferencia as <em class="markup--em markup--p-em">shared libraries</em> das bibliotecas de rotina estática é a <em class="markup--em markup--p-em">ligação</em>: os símbolos no executável que se referem à <em class="markup--em markup--p-em">shared library</em> são resolvidos em tempo de execução ao invés de ser durante a compilação. E isso tem consequências interessantes.</p><p name="60b4" id="60b4" class="graf graf--p graf-after--p">A primeira consequência é o tamanho do executável final. O executável é menor, o que facilita o seu <em class="markup--em markup--p-em">deployment</em>. Com parte das rotinas está na biblioteca compartilhada, o executável não precisa ter todo o código enfiado dentro de si. </p><p name="73a9" id="73a9" class="graf graf--p graf-after--p">A segunda consequência é uma decorrência da primeira: você pode atualizar somente parte do seu sistema ao atualizar somente as rotinas que estão na biblioteca, ao invés de atualizar todo o seu sistema.</p><p name="9f0c" id="9f0c" class="graf graf--p graf-after--p">Existem prós e contras em relação ao uso das bibliotecas dinâmicas. Sim, as <em class="markup--em markup--p-em">shared libraries</em> também são chamadas de bibliotecas dinâmicas. </p><h4 name="d283" id="d283" class="graf graf--h4 graf-after--p">Prós e Contras</h4><p name="12ec" id="12ec" class="graf graf--p graf-after--h4">Vale a pena usá-las? Depende do contexto. É preciso avaliar bem quando usar ou não uma biblioteca compartilhada. O primeiro contra refere-se ao <em class="markup--em markup--p-em">setup </em>do ambiente de execução. É preciso fazer com que o <em class="markup--em markup--p-em">linker</em> saiba onde está sua biblioteca para que seu executável seja carregado com sucesso.</p><p name="5a54" id="5a54" class="graf graf--p graf-after--p">Nos sistemas <em class="markup--em markup--p-em">unix like</em>, isto é feito ajustando-se a variável de ambiente <code class="markup--code markup--p-code">LD_LIBRARY_PATH</code>. Esta variável contém uma lista de locais que devem ser pesquisados para que as referências do seu executável às bibliotecas dinâmicas sejam satisfeitas. Se o linker não conseguir encontrar as referências, o <em class="markup--em markup--p-em">loader</em> termina a execução e simplesmente mata seu executável com uma mensagem de erro.</p><p name="fdd1" id="fdd1" class="graf graf--p graf-after--p">O segundo problema refere-se à segurança. Uma pessoa mal intencionada pode trocar sua biblioteca por outra, injetando código malicioso no seu executável. O Windows é particularmente sucetível a este tipo de problema pois é possível injetar uma DLL, o equivalente à <em class="markup--em markup--p-em">shared library </em>do unix, em qualquer processo (referência: <a href="https://www.amazon.com/Advanced-Windows-Jeffrey-Richter/dp/1572315482" data-href="https://www.amazon.com/Advanced-Windows-Jeffrey-Richter/dp/1572315482" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Advanced Windows — Jeffrey Richter</a>). </p><p name="21fe" id="21fe" class="graf graf--p graf-after--p">O terceiro problema é o tempo de carga do seu executável. O uso de bibliotecas dinâmicas acaba ampliando o tempo necessário para o loader carregar seu programa na memória. E não é para menos: é preciso resolver todos os símbolos pendentes antes do seu programa entrar em execução.</p><p name="2542" id="2542" class="graf graf--p graf-after--p">Mas nem tudo são problemas. O uso de shared libraries permite que seu programa ocupe menos espaço em memória, resolvendo símbolos só quando for necessário. Em verdade, isto precisa ser feito de maneira manual através de system calls <code class="markup--code markup--p-code">dlopen, dlclose e dlsym</code> no unix. Chamadas semelhantes existem no Windows. O seu programa pode carregar, resolver os símbolos, executar o que precisa e descarregar as bibliotecas ao seu bem querer. Isto é particularmente muito interessante no design de plugins e extensões de um programa.</p><p name="e1c2" id="e1c2" class="graf graf--p graf-after--p">Outra vantagem é permitir que você compartilhe código com várias partes do seu sistema sem, contudo, onerar demais o armazenamento em disco. Ao colocar rotinas e recursos em bibliotecas dinâmicas, vários softwares de um sistema complexo podem usufruir dos mesmos serviços, minimizando o tempo e complexidade de deployment. </p><p name="ebe9" id="ebe9" class="graf graf--p graf-after--p">Hoje em dia praticamente todos os sistemas modernos são baseados em bibliotecas dinâmicas pela simplicidade que elas oferecem na atualização de software. Não é preciso atualizar todo o seu unix quando um problema na biblioteca de SSL é encontrado e corrigido. Basta trocar a versão da biblioteca por uma corrigida e já era.</p><h4 name="746d" id="746d" class="graf graf--h4 graf-after--p">Como funciona?</h4><p name="305f" id="305f" class="graf graf--p graf-after--h4">O mecanismo da ligação dinâmica é, na realidade, simples e tem consequências na forma como o executável é criado. Imagine que você tenha um sistema de tal forma que o executável dependa de uma biblioteca dinâmica. Ao compilar o código do seu executável, eis o que acontece, considerando que você faça uso da ligação dinâmica automática:</p><ol class="postList"><li name="7d82" id="7d82" class="graf graf--li graf-after--p">Os símbolos da biblioteca externa são mantidos como não resolvidos. Afinal, o compilador sabe quais são as interfaces, mas não tem condições de ligar o código.</li><li name="604d" id="604d" class="graf graf--li graf-after--li">Depois de devidamente compilado entra em ação o linker. Ao achar os símbolos da biblioteca externa o linker imediatamente procura resolvê-los. Ao verificar que os símbolos são resolvidos em uma biblioteca dinâmica, o linker adiciona código para realizar a carga e a resolução dos símbolos no seu executável, para que isto seja feito de forma dinâmica.</li><li name="36a2" id="36a2" class="graf graf--li graf-after--li">O seu executável é terminado e contém uma tabela de símbolos tal que os símbolos externos têm referências à bibliotecas externas, que serão resolvidos quando seu executável for efetivamente carregado.</li></ol><p name="3de4" id="3de4" class="graf graf--p graf-after--li">Quando você chama seu executável, antes de mais nada entra em ação o <em class="markup--em markup--p-em">loader</em>. Esta pequena peça de software é enfiada no seu executável pelo compilador e a sua função é preparar o ambiente de execução para que o seu programa inicie-se. Ao encontrar a tabela de símbolos dinâmicos, o loader dá um jeito de chamar o linker para resolver. O linker, aqui, é diferente do linker que você usou para gerar seu executável. Trata-se de um serviço do sistema operacional. Este linker procura pela biblioteca. Ao encontrá-la, procura pelo símbolo. Ao encontrar o símbolo, realiza as alocações pertinentes, inicializa a biblioteca dentro do espaço de endereçamento do seu programa, liga os símbolos pendentes do seu programa ao código da biblioteca e… vamos adiante!</p><p name="176e" id="176e" class="graf graf--p graf-after--p">O seu programa, finalmente, entra em execução. Ao chamar uma função da biblioteca dinâmica, esta já está resolvida e o código da biblioteca, que está carregado no espaço de endereçamento do seu executável, ou seja, dentro do processo, entra em execução como se fosse uma parte integrante do seu software.</p><p name="ff48" id="ff48" class="graf graf--p graf-after--p">É possível, no entanto, fazer a carga manualmente. Isso tem algumas vantagens. A primeira delas é que você controla quando e como as bibliotecas externas serão carregadas. Assim, você pode criar módulos externos que podem ser carregados depois do seu programa estar em execução, realizar o que precisa e depois ser descarregados. Este <em class="markup--em markup--p-em">fine control</em> é particularmente interessante em sistemas embarcados nos quais a memória é um recurso para lá de escasso. Como normalmente estes sistemas usam armazenagem em memória (flash, ROMs, EPROMs, etc), o acesso é rápido e o delay pequeno. Obviamente que esta abordagem é proibitiva para sistemas de missão crítica em tempo real. </p><h4 name="4c2e" id="4c2e" class="graf graf--h4 graf-after--p">Conclusão</h4><p name="82d2" id="82d2" class="graf graf--p graf-after--h4 graf--trailing">As bibliotecas dinâmicas trazem benefícios para o deployment de aplicações, minimizando a armazenagem necessária para os programas. Mesmo em sistemas embarcados, como o iOS, esta tecnologia, já bem antiga diga-se de passagem, sempre esteve presente, ficando disponível para os programadores fora do âmbito da Apple somente após o iOS 7. </p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/9838b98693dc">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>