<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Canais de comunicação</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Canais de comunicação</h1>
</header>
<section data-field="subtitle" class="p-summary">
Sim, o seu software comunica-se sempre!
</section>
<section data-field="body" class="e-content">
<section name="fdb2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="05cb" id="05cb" class="graf graf--h3 graf--leading graf--title">Canais de comunicação</h3><h4 name="aabd" id="aabd" class="graf graf--h4 graf-after--h3 graf--subtitle">Sim, o seu software comunica-se sempre!</h4><figure name="2256" id="2256" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*5NI8U4JRNw5O4aJ1dfRHfw.jpeg" data-width="4272" data-height="2848" src="https://cdn-images-1.medium.com/max/800/1*5NI8U4JRNw5O4aJ1dfRHfw.jpeg"></figure><p name="c7ba" id="c7ba" class="graf graf--p graf-after--figure">Qualquer que seja o software que você esteja escrevendo, ele está se comunicando. Sempre. A comunicação pode ocorrer entre os componentes do seu software, entre classes de um mesmo componente, entre classes do framework que você usa ou através de uma rede, como a internet, com componentes ou serviços remotos.</p><p name="0ca6" id="0ca6" class="graf graf--p graf-after--p">Trata-se de algo tão comum, tão corriqueiro que esquecemos de observar com cuidado o fenômeno da comunicação dentro de um software, muitas vezes causando um aumento no acoplamento e criando dependências funcionais e temporais. Em outros casos, os canais de comunicação tornam-se gargalos justamente por que se sobrecarregam facilmente. Este pequeno artigo visa demonstrar quando a comunicação acontece e apresenta algumas ideias de como criar software mais eficiente, tirando proveito de alguns princípios bem antigos.</p><h4 name="9e73" id="9e73" class="graf graf--h4 graf-after--p">Estados globais compartilhados</h4><p name="a934" id="a934" class="graf graf--p graf-after--h4">Esta é a forma mais primitiva de comunicar-se dentro de um software. Imagine que seu software precise manter um estado, qualquer que seja, no âmbito global. Por exemplo, um cliente pode manter como estado global compartilhado uma sessão de usuário, sessão esta deve estar necessariamente ativa para que o usuário possa utilizar as funcionalidades deste cliente.</p><p name="34cd" id="34cd" class="graf graf--p graf-after--p">Os estados globais compartilhados são primitivos pois exigem bastante cuidado. Se duas linhas de processamento tentam alterar, ao mesmo tempo, o estado global, pode-mos ter situações de concorrência que podem resultar em comportamentos imprevisíveis. Se pensarmos no estado global compartilhado, teremos duas operações possíveis: escrita e leitura. Em termos de canais de comunicação, é isto o que acontece: alguém escreve no canal e outro alguém lê deste canal.</p><p name="daf3" id="daf3" class="graf graf--p graf-after--p">Bem, com o estado global compartilhado a regra vale: você terá alguém escrevendo no estado, por exemplo a rotina que realiza a autenticação do usuário e altera o estado global; e terá, também, alguém lendo, por exemplo a rotina que verifica se o usuário foi autenticado para permitir o acesso a alguma funcionalidade.</p><p name="fc80" id="fc80" class="graf graf--p graf-after--p">Quando o canal de comunicação é escrito e lido pelo mesmo processo, dizemos que ele é <em class="markup--em markup--p-em">full duplex</em>. Caso uma rotina simplesmente escreva no estado global, sem antes verificá-lo, dizemos que esta rotina usa um canal <em class="markup--em markup--p-em">half duplex</em>.</p><h4 name="86c0" id="86c0" class="graf graf--h4 graf-after--p">Protocolo</h4><p name="7e82" id="7e82" class="graf graf--p graf-after--h4">Já que falamos do estado global compartilhado, é importante falarmos de protocolos. Notem, estamos falando de código dentro do seu software. Nada a ver com redes. Os conceitos aqui apresentados são suficientemente genéricos para, inclusive, servirem para comunicações remotas, ou seja, através de uma rede arbitrária de comunicação.</p><p name="dbff" id="dbff" class="graf graf--p graf-after--p">O <em class="markup--em markup--p-em">protocolo</em> nada mais é que uma regra estabelecida entre os comunicantes, ou seja, uma forma de padronizar a comunicação de tal forma que os dois participantes da comunicação possam compreender corretamente as mensagens trocadas. No caso do nosso estado global compartilhado, é importante determinar-se um <em class="markup--em markup--p-em">protocolo</em>.</p><p name="4225" id="4225" class="graf graf--p graf-after--p">Normalmente um estado global compartilhado é implementado como um <em class="markup--em markup--p-em">singleton</em>, uma forma moderna de criar-se uma variável global. Se o acesso é feito inescrupulosamente, sem o devido encapsulamento, teremos uma variável global acessada para leitura e escrita sem nenhum critério, o que pode levar a um código bastante instável e dependente.</p><p name="ae36" id="ae36" class="graf graf--p graf-after--p">Assim, a adoção de um protocolo pode facilitar o compartilhamento de informações e transmissão de instruções entre dois comunicantes, estipulando regras, inclusive, de integridade.</p><h4 name="b749" id="b749" class="graf graf--h4 graf-after--p">Ativação de métodos ou funções</h4><p name="0f6d" id="0f6d" class="graf graf--p graf-after--h4">Uma outra forma de comunicação dentro do seu software é a ativação de métodos ou funções. E aqui também vale o conceito de leitura e escrita: ao ativar um método passando parâmetros você pode entender que está escrevendo no objeto que está ativando. Certamente os parâmetros serão avaliados para ocasionar uma mudança de estado. Se o método apenas retorna um valor, a sua rotina está lendo do objeto. O caso geral é quando temos um método que recebe parâmetros e retorna valores — este é um caso de full duplex.</p><p name="f3f8" id="f3f8" class="graf graf--p graf-after--p">E quando o método é apenas ativado sem receber nenhum parâmetro e sem retornar nenhum valor? Este é um caso de escrita. Fazendo uma analogia ao <em class="markup--em markup--p-em">smalltalk</em>, ao ativar o método você está, na verdade, enviando uma mensagem ao objeto, mensagem esta que provocará uma mudança de estado neste objeto. Portanto, podemos entender este caso como uma escrita solicitada ao objeto.</p><p name="11c7" id="11c7" class="graf graf--p graf-after--p">Os métodos e as funções são, portanto, canais de comunicação entre rotinas. A assinatura do método ou função determina o <em class="markup--em markup--p-em">protocolo</em> de comunicação que é verificado em tempo de compilação. Apesar de mais sofisticado, este mecanismo ainda é bastante primitivo e é uma das primitivas dos esquemas de programação procedural e orientada ao objeto.</p><h4 name="9fbb" id="9fbb" class="graf graf--h4 graf-after--p">Notificações</h4><p name="ce9e" id="ce9e" class="graf graf--p graf-after--h4">As notificações, amplamente utilizadas em sistemas como o iOS, são um exemplo de comunicação <em class="markup--em markup--p-em">half-duplex</em>. Trata-se de um esquema simples, porém mais sofisticado que a ativação de métodos. Neste esquema, uma notificação é gerada por quem deseja escrever dados e interessados são notificados para que possam ler os dados escritos no canal e, assim, realizar algum tipo de processamento.</p><p name="d629" id="d629" class="graf graf--p graf-after--p">Este esquema de processamento é uma distribuição de mensagens <em class="markup--em markup--p-em">multi-cast</em>, ou seja, somente interessados inscritos no grupo de notificação receberão a mensagem. O que é interessante neste esquema de comunicação é que as regras são bem definidas (protocolo) e assim qualquer entidade do seu software pode participar do grupo multi-cast contanto que entendar e adapte-se às regras.</p><p name="4dcf" id="4dcf" class="graf graf--p graf-after--p">A notificação tem como principal vantagem desacoplar completamente comportamentos dos emissores de dados. Assim, um emissor não sabe quem efetivamente vai receber a mensagem. A mensagem é publicada em um canal que a distribui aos receptores interessados.</p><h4 name="8f9f" id="8f9f" class="graf graf--h4 graf-after--p">Pipes</h4><p name="6232" id="6232" class="graf graf--p graf-after--h4">Os <em class="markup--em markup--p-em">pipes </em>são canais de comunicação que podem ser <em class="markup--em markup--p-em">half-duplex </em>ou <em class="markup--em markup--p-em">full-duplex</em>. Normalmente são encontrados em sistemas operacionais mas podem ser facilmente implementados em rotinas de usuário. A função do <em class="markup--em markup--p-em">pipe</em> é servir de transporte de mensagens entre um par emissor/receptor. Assim, cria-se um canal de comunicação entre o emissor e o receptor de forma a permitir a comunicação de dados entre eles.</p><p name="98f6" id="98f6" class="graf graf--p graf-after--p">Nos sistemas operacionais os <em class="markup--em markup--p-em">pipes</em> permitem que processos não relacionados comuniquem-se. Faz parte do stack IPC (<em class="markup--em markup--p-em">inter-process communication</em>). De maneira conceitual, podem ser síncronos ou assíncronos. No caso do <em class="markup--em markup--p-em">pipe</em> assíncrono, o emissor escreve os dados que precisa escrever sem preocupar-se se o receptor receberá os dados.</p><h4 name="f681" id="f681" class="graf graf--h4 graf-after--p">Data Bus</h4><p name="865f" id="865f" class="graf graf--p graf-after--h4">O conceito de <em class="markup--em markup--p-em">data bus</em> não é novo e não é novidade. Muito menos é uma coqueluche da tecnologia e nem é algo espetacular. A ideia é antiga e os computadores usam <em class="markup--em markup--p-em">data buses</em> há anos para trocar informações entre seus componentes (por exemplo, entre processador e memória).</p><p name="910c" id="910c" class="graf graf--p graf-after--p">A ideia do barramento de dados é permitir a comunicação entre emissores e receptores através do mesmo meio, de maneira que os dados transitados sejam multiplexados e distribuídos dentro da mesma estrutura, maximizando o tráfego.</p><p name="bf68" id="bf68" class="graf graf--p graf-after--p">Imagine que você precisa criar um canal de comunicação para centenas de objetos. O data bus permite que você utilize somente um único canal para o tráfego de informações, mesmo que a comunicação seja <em class="markup--em markup--p-em">peer-to-peer</em>. Existem três coisas que o data bus permite:</p><ul class="postList"><li name="fb90" id="fb90" class="graf graf--li graf-after--p">comunicação <em class="markup--em markup--li-em">unicast</em>, ou seja, entre um par emissor/receptor;</li><li name="0733" id="0733" class="graf graf--li graf-after--li">comunicação <em class="markup--em markup--li-em">multicast</em>, ou seja, em um emissor e vários receptores selecionados;</li><li name="174b" id="174b" class="graf graf--li graf-after--li">comunicação <em class="markup--em markup--li-em">broadcast</em>, ou seja, entre um emissor e vários receptores, sendo que o critério de entrega da mensagem é apenas o receptor participar do data bus.</li></ul><p name="2d8b" id="2d8b" class="graf graf--p graf-after--li">A diferença entre multicast e broadcast é que no primeiro modo somente quem participa de um grupo recebe a mensagem, enquanto no segundo todo mundo capaz de comunicar-se recebe a mensagem.</p><h4 name="d55c" id="d55c" class="graf graf--h4 graf-after--p">Como usar essa parafernália no dia-a-dia?</h4><p name="99a9" id="99a9" class="graf graf--p graf-after--h4">Aqui estão os conceitos. Como usá-los para otimizar seu software? Existem várias formas de usar canais de comunicação para aumentar o throughput de dados do seu software. A forma mais simples é através de filas de mensagens. As filas têm como característica sincronizar pares emissor/receptor de maneira a compatibilizar a diferença de velocidade entre ambos. Por exemplo, se um emissor gera mensagens numa taxa superior ao que o receptor consegue processar, a fila compatibiliza isto retendo os dados não processados até que o emissor tenha tempo de processá-los.</p><p name="df0f" id="df0f" class="graf graf--p graf-after--p">Você pode usar uma fila para enviar pacotes de processamento entre partes do seu software. Os receptores é quem cuidarão de receber estes pacotes e processá-los. A principal vantagem desta estrutura é desacoplar completamente quem cria a mensagem de quem a processa efetivamente. Assim, o emissor não faz a menor ideia de quem seja o receptor, apenas conhece o que precisa fazer para enviar algo pela fila.</p><p name="0ae6" id="0ae6" class="graf graf--p graf-after--p">Em uma estrutura de processamento complexo pode-se usar um princípio chamado de <em class="markup--em markup--p-em">pipeline</em>. Tratam-se de vários processos especialistas interligados por filas de mensagem. Um emissor publica na primeira fila uma mensagem que é passada para um receptor, cujo resultado de processamento é publicado em outra fila e assim por diante. Se cada processo estiver em uma <em class="markup--em markup--p-em">thread</em> ou processo diferente, consegue-se obter paralelismo de processamento sem, contudo, incorrer-se em problemas de concorrência, pois cada receptor cuidará de uma única coisa.</p><p name="f5b8" id="f5b8" class="graf graf--p graf-after--p">Caso o seu pipeline não seja paralelizado, ainda assim consegue-se concorrência por distribuir o processamento por vários estágios, criando-se um fluxo muito bem definido de trabalho. A beleza dessa estrutura é que o elemento anterior não faz a menor ideia do que é o elemento posterior. Assim, todo o processamento é realizado por peças de software praticamente independentes funcionalmente falando.</p><p name="d6d2" id="d6d2" class="graf graf--p graf-after--p">Ao criar um fluxo bem definido, com uma estrutura de mensagens bem clara, você pode, também, criar um workflow dentro da sua aplicação de forma que o tipo da mensagem possa disparar esquemas de multicast ou broadcast inteligentes, ou seja, somente os interessados no tipo da mensagem a usam para processamento, dando a oportunidade de várias peças do seu software atuarem de maneira ordenada.</p><p name="8f83" id="8f83" class="graf graf--p graf-after--p graf--trailing">É isso. Happy coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/22247d6fda81"><time class="dt-published" datetime="2017-01-29T18:02:04.882Z">January 29, 2017</time></a>.</p><p><a href="https://medium.com/@ronaldolima/canais-de-comunica%C3%A7%C3%A3o-22247d6fda81" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>