<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Optionals: quebrando tudo com swift!</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Optionals: quebrando tudo com swift!</h1>
</header>
<section data-field="subtitle" class="p-summary">
Esta é, sem dúvida, a feature mais quente do swift.
</section>
<section data-field="body" class="e-content">
<section name="3f7a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="559d" id="559d" class="graf graf--h3 graf--leading graf--title">Optionals: quebrando tudo com swift!</h3><h4 name="a8dd" id="a8dd" class="graf graf--h4 graf-after--h3 graf--subtitle">Esta é, sem dúvida, a feature mais quente do swift.</h4><figure name="bb22" id="bb22" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*F0DxrY5aXA9DGpdB_jySww.jpeg" data-width="4896" data-height="3264" src="https://cdn-images-1.medium.com/max/800/1*F0DxrY5aXA9DGpdB_jySww.jpeg"></figure><p name="faf4" id="faf4" class="graf graf--p graf-after--figure">Entre todas as características da linguagem Swift, a que mais me chamou a atenção, quando a Apple apresentou a linguagem pela primeira vez, foi o uso de opcionais. Essa foi, sem dúvida, uma grande sacada e uma forma bem interessante de homogeneizar um conceito já há muito tempo arraigado na computação: o problema do valor inicial.</p><p name="97da" id="97da" class="graf graf--p graf-after--p">A ideia por trás do opcional é simples: criar uma variável cujo valor seja opcional. Isto quer dizer o seguinte: esta variável é de um tipo bem determinado, mas o valor que ela carrega é opcional. Ou seja, em algum momento no ciclo de vida desta variável ela conterá um valor que indica que ela está vazia, ou seja, não tem valor algum.</p><p name="9b5e" id="9b5e" class="graf graf--p graf-after--p">Para entender por que este conceito é legal, vamos pensar no seguinte problema: precisamos determinar o maior número de um conjunto finito de números. Se fôssemos resolver este problema em C, teríamos algo como isto:</p><pre name="bf0e" id="bf0e" class="graf graf--pre graf-after--p">int max (int *numbers, int size) {<br>  int greater = -1;<br>  int *p = numbers;<br>  while (p - numbers &lt; size) {<br>    if (*p &gt; greater) {<br>      greater = *p;<br>    }<br>    ++p;<br>    return greater;<br>  }<br>}</pre><p name="eb65" id="eb65" class="graf graf--p graf-after--pre">Considere que <em class="markup--em markup--p-em">numbers</em> é um array de números inteiros e <em class="markup--em markup--p-em">size</em> é o tamanho deste array. Aritméticas de ponteiro à parte, o algoritmo é bem simples: ele inicializa <em class="markup--em markup--p-em">greater </em>com um valor inicial e sai comparando este número com todos os demais existentes no array.</p><p name="49df" id="49df" class="graf graf--p graf-after--p">É um algoritmo sem-vergonha. Se a lista de números for toda negativa com números menores que -1, está feita a merda. Uma saída simples é inicializar <em class="markup--em markup--p-em">greater</em> com o primeiro elemento do array e sair comparando com o resto, o que resolveria o problema, mas não ilustraria o que quero com os opcionais. Reescrevendo esta jóia em Swift, teremos algo assim:</p><pre name="9575" id="9575" class="graf graf--pre graf-after--p">func max (numbers: [Int])-&gt; Int {<br>    var max: Int?<br>    for x in numbers {<br>        if max == nil || max! &lt; x {<br>            max = x<br>        }<br>    }<br>    return max!<br>}</pre><p name="3061" id="3061" class="graf graf--p graf-after--pre">Observe que <em class="markup--em markup--p-em">max </em>é do tipo inteiro, mas com uma interrogação na frente. Isto quer dizer que <em class="markup--em markup--p-em">max</em> é uma variável opcional. A despeito da péssima escolha de nomes para a função e sua variável local, há alguma coisa interessante acontecendo por aqui.</p><p name="5d6e" id="5d6e" class="graf graf--p graf-after--p">Para que você acesse o valor de uma variável opcional é necessário realizar um processo chamado de <em class="markup--em markup--p-em">unwrapping</em>. O que acontece é o seguinte: ao declarar uma variável como opcional o compilador gera uma estrutura de código em torno dela para que um valor especial, <em class="markup--em markup--p-em">nil, </em>seja armazenado nela. A palavra <em class="markup--em markup--p-em">nil </em>é uma contração da palavra latina <em class="markup--em markup--p-em">nihil</em>, que significa, no bom português, <em class="markup--em markup--p-em">nada</em>.</p><p name="6bd5" id="6bd5" class="graf graf--p graf-after--p">Em Objective C era possível usar <em class="markup--em markup--p-em">nil </em>como valor inválido, mas apenas para variáveis estruturadas como classes e estruturas. Variáveis de tipos integrais não podiam usar esta característica, o que criava um hiato na linguagem.</p><p name="240e" id="240e" class="graf graf--p graf-after--p">Bom, em Swift você pode usar opcional em qualquer tranqueira que inventar, não importa se sua variável é estruturada ou integral. Isso homogeiniza as coisas. No nosso exemplinho sem-vergonha, há uma verificação explícita contra <em class="markup--em markup--p-em">nil</em>, apesar de não haver nenhuma inicialização explícita para este valor. Isto se deve ao fato do runtime do Swift inicializar automaticamente os opcionais com o valor <em class="markup--em markup--p-em">nil</em>.</p><p name="0968" id="0968" class="graf graf--p graf-after--p">Para realizar o <em class="markup--em markup--p-em">unwrapping</em> é preciso usar dois pequenos operadores: ? ou !. No exemplo, usei o operador !, que faz o <em class="markup--em markup--p-em">unwrapping </em>forçado, enquanto que o operador ? faz o <em class="markup--em markup--p-em">unwrapping </em>condicionado. Qual a diferença entre eles?</p><p name="36e5" id="36e5" class="graf graf--p graf-after--p">Se a variável tiver um valor <em class="markup--em markup--p-em">nil</em>, ou seja, um valor inválido, o <em class="markup--em markup--p-em">unwrapping </em>forçado vai provocar uma falha de runtime e sua aplicação vai cair de forma descontrolada. No caso do <em class="markup--em markup--p-em">unwrapping</em> condicionado, o runtime tentará extrair o valor da variável. Se a variável for <em class="markup--em markup--p-em">nil</em>, nada acontece.</p><p name="2ba2" id="2ba2" class="graf graf--p graf-after--p">Assim, você deve usar o <em class="markup--em markup--p-em">unwrapping </em>forçado sempre que tiver certeza de que a variável tem um valor válido nela, como foi o caso do nosso algoritmo sem-vergonha.</p><p name="a368" id="a368" class="graf graf--p graf-after--p">Uma construção muito comum para realizar o <em class="markup--em markup--p-em">unwrapping</em> é através do if:</p><pre name="fdaa" id="fdaa" class="graf graf--pre graf-after--p">if let valorUnwrapped = valorOpcional {<br>}</pre><p name="c490" id="c490" class="graf graf--p graf-after--pre">Se <em class="markup--em markup--p-em">valorOpcional</em> tiver um valor válido, ele é atribuído a <em class="markup--em markup--p-em">valorUnwrapped</em> e você pode usar esta constante dentro do <em class="markup--em markup--p-em">if</em> sem se preocupar com o danadinho do <em class="markup--em markup--p-em">nil</em>. Isto é equivalente a fazer o seguinte:</p><pre name="d1e4" id="d1e4" class="graf graf--pre graf-after--p">if valorOpcional != nil {<br>    let valorUnwrapped = valorOpcional!<br>}</pre><h4 name="60b2" id="60b2" class="graf graf--h4 graf-after--pre">Unwrapping Automático</h4><p name="a2ac" id="a2ac" class="graf graf--p graf-after--h4">Você pode declarar uma variável assim:</p><pre name="b307" id="b307" class="graf graf--pre graf-after--p">var idade: Int!<br><br></pre><p name="01e1" id="01e1" class="graf graf--p graf-after--pre">Isso daí é muito comum quando você cria <em class="markup--em markup--p-em">outlets</em> no seu código, quando está programando no Cocoa Touch ou no Cocoa. Esta sintaxe quer dizer o seguinte: idade é uma variável opcional, mas cujo <em class="markup--em markup--p-em">unwrapping</em> será implícito.</p><p name="c39b" id="c39b" class="graf graf--p graf-after--p">Assim, pode-se fazer o teste deste tipo de variável contra <em class="markup--em markup--p-em">nil</em> para verificar-se se a variável é válida. Tentar acessar uma variável opcional sem que ela tenha um valor válido vai provocar um erro no seu programa.</p><p name="a3cc" id="a3cc" class="graf graf--p graf-after--p">Assim:</p><pre name="6dcb" id="6dcb" class="graf graf--pre graf-after--p">var outro = idade + 1</pre><p name="2461" id="2461" class="graf graf--p graf-after--pre">provoca um erro em tempo de execução. Ao tentar fazer o unwrapping de idade, runtime verifica que não há valor válido e aí a casa cai. O ideal, aqui seria fazer algo como abaixo</p><pre name="2e97" id="2e97" class="graf graf--pre graf-after--p">var outro = 0<br>if idade == nil {<br> outro = idade + 1<br>}</pre><p name="7872" id="7872" class="graf graf--p graf-after--pre">Observe que não foi preciso indicar o unwrapping de <em class="markup--em markup--p-em">idade</em>. O <em class="markup--em markup--p-em">unwrapping</em> é feito automaticamente pelo runtime.</p><h4 name="8969" id="8969" class="graf graf--h4 graf-after--p">Anti-patterns</h4><p name="22aa" id="22aa" class="graf graf--p graf-after--h4">Já falei do trem bonito. Agora é hora de falar do trem feio. Tem um raio de um povo que faz unwrapping desta forma:</p><pre name="7422" id="7422" class="graf graf--pre graf-after--p">if let valorOpcional = valorOpcional {<br>}</pre><p name="3b75" id="3b75" class="graf graf--p graf-after--pre">A ideia é aproveitar o nome da variável. Nem preciso dizer que isso é uma péssima ideia. Funciona, mas deixa seu código bem mais escroto de ler. Muitas vezes o povo usa esta forma apenas para saber se a variável é válida ou não.</p><p name="09ea" id="09ea" class="graf graf--p graf-after--p">Outro anti-pattern interessante é fazer isto para ativar métodos de objetos opcionais:</p><pre name="eb5e" id="eb5e" class="graf graf--pre graf-after--p">if let objetoOpcional = objetoOpcional {<br> objetoOpcional.metodoDescolado()<br>}</pre><p name="172f" id="172f" class="graf graf--p graf-after--pre">Por que isso é ruim? Por que dá para fazer a mesma coisa sem essa tanteira de código:</p><pre name="0f39" id="0f39" class="graf graf--pre graf-after--p">objetoOpcional?.metodoDescolado()</pre><p name="36b9" id="36b9" class="graf graf--p graf-after--pre">Faz a mesma coisa. O ? quer dizer que fazemos o unwrapping condicionado, ou seja, se tiver algo lá, executa o método, senão não faz nada.</p><p name="a7be" id="a7be" class="graf graf--p graf-after--p">Bem, é isso aí. Espero que isso esclareça dúvidas quanto ao uso de opcionais no seu programa.</p><p name="758d" id="758d" class="graf graf--p graf-after--p graf--trailing">Happy Coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/6cbfebae82c8"><time class="dt-published" datetime="2016-08-31T11:01:02.207Z">August 31, 2016</time></a>.</p><p><a href="https://medium.com/@ronaldolima/optionals-quebrando-tudo-com-swift-6cbfebae82c8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>