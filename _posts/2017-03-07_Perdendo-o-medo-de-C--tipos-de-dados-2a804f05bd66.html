<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Perdendo o medo de C: tipos de dados</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Perdendo o medo de C: tipos de dados</h1>
</header>
<section data-field="subtitle" class="p-summary">
Todo dado tem seu tipo. Todo tipo tem seu dado…
</section>
<section data-field="body" class="e-content">
<section name="01e5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="00f8" id="00f8" class="graf graf--h3 graf--leading graf--title">Perdendo o medo de C: tipos de dados</h3><h4 name="75b9" id="75b9" class="graf graf--h4 graf-after--h3 graf--subtitle">Todo dado tem seu tipo. Todo tipo tem seu dado…</h4><figure name="3125" id="3125" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*CtL7L-xuiyljKBcX6kxjug.jpeg" data-width="4608" data-height="3072" src="https://cdn-images-1.medium.com/max/800/1*CtL7L-xuiyljKBcX6kxjug.jpeg"></figure><p name="a3a7" id="a3a7" class="graf graf--p graf-after--figure">Dando continuidade à série de artigos sobre linguagem C, me permitam falar dos tipos de dados. Bem, C é uma linguagem de <em class="markup--em markup--p-em">tipagem estática</em>, ou seja, uma vez que você tenha definido um objeto como sendo de um tipo, este objeto permanece deste tipo até o fim da sua vida. Antes de seguir adiante, um parênteses.</p><blockquote name="5d61" id="5d61" class="graf graf--blockquote graf-after--p">&quot;Objeto&quot; neste contexto não é uma instância de uma classe. C não é orientado ao objeto. Aqui, quando falo &quot;objeto&quot; me refiro a um elemento da linguagem que é algo pronto para ser utilizado, como uma constante, uma variável ou uma função. A literatura trata estes elementos da linguagem como &quot;objetos&quot; e achei por bem manter a nomenclatura, por mais que possa causar confusão.</blockquote><p name="c191" id="c191" class="graf graf--p graf-after--blockquote">Parênteses fechado, vamos adiante. Como eu disse, C é uma linguagem de tipagem estática. Existem dois conceitos importantes que preciso apresentar antes de seguir adiante. O primeiro é a <strong class="markup--strong markup--p-strong">declaração</strong>. Quando você declara algo você quer dizer como este <em class="markup--em markup--p-em">algo</em> deverá ser usado. Se este algo for uma função, declará-la diz ao compilador o que é que ela recebe como parâmetro e o que ela pode retornar. O segundo conceito é a <strong class="markup--strong markup--p-strong">definição</strong>. Quando você define algo, você diz para o compilador o que é que este algo faz. Portanto, quando você <em class="markup--em markup--p-em">define uma função</em> você está, na verdade, escrevendo o código do corpo desta função.</p><p name="063d" id="063d" class="graf graf--p graf-after--p">Mesmo as variáveis podem sofrer desta distinção. Ao declarar uma variável, você pode deixar para definí-la posteriormente. Isto leva o nome bonito de <em class="markup--em markup--p-em">forward definition</em>. Me lembrem de voltar a isto depois.</p><p name="cdbb" id="cdbb" class="graf graf--p graf-after--p">Bom, temos basicamente dois tipos de dados em C: os tipos integrais e os tipos estruturados. Os tipos integrais são tipos simples, que suportam apenas um único valor de cada vez. Os tipos estruturados permitem armazenar vários valores diferentes no mesmo lugar, permitindo que seu programa trabalhe com estruturas complicadas de dados através de uma única variável.</p><p name="9486" id="9486" class="graf graf--p graf-after--p">Entre os tipos integrais, temos os seguintes: <code class="markup--code markup--p-code">int, float, double, char</code>. Apesar de parecer um contra-senso, <code class="markup--code markup--p-code">char</code> é um tipo numérico que acumula valores de 1 byte, ou seja, números de -128 a +127, podendo ser de 0 a 255 se for utilizado um<em class="markup--em markup--p-em"> modificador de tipo.</em></p><p name="7f59" id="7f59" class="graf graf--p graf-after--p">Os modificadores de tipo para os tipos numéricos são: <code class="markup--code markup--p-code">unsigned, long.</code> O primeiro declara um tipo numérico sem sinal e o segundo um tipo longo. Normalmente ambos são usados para tipos inteiros.</p><p name="79e2" id="79e2" class="graf graf--p graf-after--p">Os tipos estruturados permitidos em C são as estruturas e os vetores. As estruturas são tipos compostos que permitem que valores de tipos distintos sejam agrupados em um único lugar. Os vetores permitem que vários valores do mesmo tipo sejam armazenados no mesmo lugar. Os vetores podem ser unidimensionais ou multidimensionais. A literatura normalmente se refere aos vetores, de forma mais acertada na minha opinião, como matrizes.</p><p name="b169" id="b169" class="graf graf--p graf-after--p">Existe um tipo integral do qual não falei que é, na verdade, um caso especial de números inteiros: as enumerações. As enumerações, em C, são conjuntos limitados de valores que podem ser usados como constantes. C permite que somente números inteiros sejam usados como membros de uma enumeração.</p><p name="a55c" id="a55c" class="graf graf--p graf-after--p">Uma <em class="markup--em markup--p-em">variável</em> é um objeto dentro do seu programa que armazena um determinado valor de um determinado tipo temporariamente. É temporário pois quando o seu programa sai da memória, o valor de qualquer variável se perde. Assim, podemos começar a ver exemplos de declarações de variáveis.</p><pre name="e3d2" id="e3d2" class="graf graf--pre graf-after--p">int x;         /* x é uma variável inteira com sinal */<br>unsigned y;    /* y é uma variável inteira sem sinal */<br>long z;        /* z é uma variável inteira longa */<br>char name[11]; /* name é um vetor de char, com 11 posições */<br>struct {<br>    char name[41];<br>    unsigned age;<br>    unsigned char married;<br>} record;      /* record é uma estrutura de dados */</pre><h4 name="1926" id="1926" class="graf graf--h4 graf-after--pre">Strings</h4><p name="71dc" id="71dc" class="graf graf--p graf-after--h4">Nos exemplos eu criei alguns vetores de <code class="markup--code markup--p-code">char</code> . Como eu disse, <code class="markup--code markup--p-code">char</code> é um tipo numérico inteiro. O fato de <code class="markup--code markup--p-code">char</code> ocupar apenas um único byte tem um sentido importante: quando foi criada, a linguagem C não precisava tratar com encodings complexos como o Unicode. O padrão era a codificação ASCII que cabia em apenas um único byte.</p><p name="b516" id="b516" class="graf graf--p graf-after--p">Assim, toda e qualquer cadeia de caracteres poderia ser descrita como uma sequência de números variando de 0 a 255. Assim, uma string em C é, na verdade, um vetor de <code class="markup--code markup--p-code">char</code> , sendo que o último caractere de uma string precisa ser, necessariamente, o valor 0 (0x0 em hexadecimal ou &#39;\0&#39; como um literal <code class="markup--code markup--p-code">char</code>).</p><p name="c2aa" id="c2aa" class="graf graf--p graf-after--p">Isto significa dizer que C não tem suporte nativo a unicode. Se você precisa processar unicode, deverá usar uma biblioteca externa. A linguagem define somente a manipulação de caracteres baseados em codificação de 1 byte.</p><p name="af78" id="af78" class="graf graf--p graf-after--p">Bem, strings em C são vetores de caracteres terminados com um caractere zero. Isto permite que a string não tenha limitação quanto ao seu tamanho. Pode ser de qualquer tamanho. A quantidade de caracteres de uma string é a contagem de caracteres diferentes de zero que existem na string.</p><h4 name="54a0" id="54a0" class="graf graf--h4 graf-after--p">Ponteiros</h4><p name="824a" id="824a" class="graf graf--p graf-after--h4">Impossível falar de strings e matrizes sem falar de ponteiros. Este é o tipo de dado que mais causa confusão a quem está aprendendo C: os ponteiros. O ponteiro, na verdade, é um número inteiro, sem sinal. O que é armazenado no ponteiro é um endereço de memória. E aqui cabe outro parênteses.</p><p name="4944" id="4944" class="graf graf--p graf-after--p">Tudo o que pertence ao seu programa é armazenado, temporariamente, em algum lugar da memória do seu computador. A <em class="markup--em markup--p-em">memória</em> pode ser física ou virtual. A memória física é a memória <em class="markup--em markup--p-em">de facto</em>, ou seja, é um chip projetado especificamente para armazenar informações temporariamente. A memória virtual é criada pelo sistema operacional e é armazenada em disco. Ou seja, o disco é usado como memória.</p><p name="8a7c" id="8a7c" class="graf graf--p graf-after--p">O <em class="markup--em markup--p-em">tamanho</em> de um ponteiro depende do tamanho máximo do registrador de endereçamento da CPU. Atualmente, o tamanho do ponteiro é de 64 bits (8 bytes) nas CPUs modernas.</p><p name="bc13" id="bc13" class="graf graf--p graf-after--p">Normalmente o ponteiro refere-se à memória que existe dentro dos limites do seu programa. Como os sistemas operacionais trabalham, atualmente, em modo <em class="markup--em markup--p-em">protegido</em>, é impossível para um programa tentar acessar um endereço que não pertença ao seu próprio programa, a não ser que se trate de memória compartilhada — um conceito existente no unix.</p><p name="9c1e" id="9c1e" class="graf graf--p graf-after--p">A ideia por detrás do ponteiro é bem simples: ele funciona como uma <em class="markup--em markup--p-em">referência</em> a algum objeto do seu programa. O ponteiro tem este nome por que ele <em class="markup--em markup--p-em">aponta </em>para um endereço de memória onde está informação. Por exemplo:</p><pre name="e292" id="e292" class="graf graf--pre graf-after--p">int a = 10;<br>int *b = &amp;a;</pre><p name="ef10" id="ef10" class="graf graf--p graf-after--pre">A variável <code class="markup--code markup--p-code">a</code> é um número inteiro que é inicializado com o valor 10. A variável <code class="markup--code markup--p-code">b</code> é um ponteiro que referencia um valor inteiro e que está inicializado com o endereço de <code class="markup--code markup--p-code">a</code>. O operador <code class="markup--code markup--p-code">&amp;</code>, como você já deve ter imaginado, extrai o endereço de memória onde <code class="markup--code markup--p-code">a</code> está armazenado.</p><p name="0f9f" id="0f9f" class="graf graf--p graf-after--p">Se traduzirmos este trecho de código para o bom português, o que queremos dizer ali é o seguinte:</p><pre name="d484" id="d484" class="graf graf--pre graf-after--p">Declare a variável &quot;a&quot; como inteira com sinal e defina seu valor como 10;<br>Declare a variável &quot;b&quot; como ponteiro para um inteiro com sinal e defina seu valor para o endereço de memória onde &quot;a&quot; está armazenado.</pre><p name="a45f" id="a45f" class="graf graf--p graf-after--pre">Isto quer dizer que se acessarmos o conteúdo do endereço de memória armazenado em <code class="markup--code markup--p-code">b</code>, conseguiremos ver o valor <code class="markup--code markup--p-code">10</code> lá dentro, pois <code class="markup--code markup--p-code">b</code> agora é uma referência para <code class="markup--code markup--p-code">a</code>. Se mudarmos o conteúdo da memória para onde <code class="markup--code markup--p-code">b</code> aponta, mudamos o valor de <code class="markup--code markup--p-code">a</code>:</p><pre name="5701" id="5701" class="graf graf--pre graf-after--p">*b = 25;</pre><p name="b07f" id="b07f" class="graf graf--p graf-after--pre">Como você já pode ter imaginado, o operador <code class="markup--code markup--p-code">*</code> é usado para olhar dentro da memória para onde <code class="markup--code markup--p-code">b</code> aponta. A atribuição acima faz com que o conteúdo da memória para onde <code class="markup--code markup--p-code">b</code> aponta seja alterado para 25. Como <code class="markup--code markup--p-code">b</code> aponta para o endereço de <code class="markup--code markup--p-code">a</code>, o que estamos fazendo, efetivamente, é mudando o valor dentro de <code class="markup--code markup--p-code">a</code>.</p><p name="9705" id="9705" class="graf graf--p graf-after--p">Se você conseguiu seguir o raciocínio até aqui e entendeu que <code class="markup--code markup--p-code">b</code> é uma referência que é realizada através do endereço de memória da variável <code class="markup--code markup--p-code">a</code>, você conseguiu aprender o conceito mais complicado da linguagem C.</p><p name="55f6" id="55f6" class="graf graf--p graf-after--p">A ideia de referência é melhor percebida quando trabalhamos com parâmetros de função. Os parâmetros de função podem ser passados por referência. Neste caso, se a função alterar o valor destes parâmetros dentro dela, estes novos valores são transmitidos para as variáveis usadas como parâmetro para chamar a função.</p><blockquote name="86f4" id="86f4" class="graf graf--blockquote graf-after--p">Não existem tipos de dados além destes em C. Dicionários, listas, arrays extensíveis, stacks, filas, tabelas de hash, sets, multisets e outros tipos não são definidos pela linguagem. Caso precise de uma estrutura de dados como estas você tem duas opções: ou escreve o algoritmo ou usa uma biblioteca de terceiros que as implemente.</blockquote><h4 name="7e6d" id="7e6d" class="graf graf--h4 graf-after--blockquote">Até Aqui</h4><p name="ac3f" id="ac3f" class="graf graf--p graf-after--h4">Apresentei de forma sucinta os principais conceitos relacionados aos tipos de dados. Este artigo não tem a intenção de ser um tratado sobre o assunto, mas uma rápida introdução. O mais complicado que apresentei foi o ponteiro. Tentei usar uma forma mais direta com explicações mais abrangentes para que o conceito seja totalmente compreendido.</p><p name="ca0a" id="ca0a" class="graf graf--p graf-after--p graf--trailing">Vou finalizar por aqui pois já foi informação demais. Em outro artigo falarei dos aliases de tipo e das declarações <em class="markup--em markup--p-em">forward</em>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/2a804f05bd66"><time class="dt-published" datetime="2017-03-07T12:01:36.653Z">March 7, 2017</time></a>.</p><p><a href="https://medium.com/@ronaldolima/perdendo-o-medo-de-c-tipos-de-dados-2a804f05bd66" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>