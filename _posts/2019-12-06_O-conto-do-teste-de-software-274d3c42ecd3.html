<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>O conto do teste de software</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">O conto do teste de software</h1>
</header>
<section data-field="subtitle" class="p-summary">
A responsabilidade é do desenvolvedor!
</section>
<section data-field="body" class="e-content">
<section name="15a9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3f66" id="3f66" class="graf graf--h3 graf--leading graf--title">O conto do teste de software</h3><h4 name="9ae2" id="9ae2" class="graf graf--h4 graf-after--h3 graf--subtitle">A responsabilidade é do desenvolvedor!</h4><figure name="df50" id="df50" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*zvJpnhdbkKSjqYdFKmSDCg.jpeg" data-width="5746" data-height="3620" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*zvJpnhdbkKSjqYdFKmSDCg.jpeg"></figure><p name="bdfd" id="bdfd" class="graf graf--p graf-after--figure">Hoje muito se fala em TDD, BDD e sei lá mais que sopa de letrinhas. Deposita-se fé cega nas metodologias e o simples fica de lado. E antes que você venha me crucificar, quero deixar algo bem claro: eu não sou, e nunca fui, contra o teste de software. As minhas críticas e insights são basicamente contra modismos que causam mais estrago do que dão resultado que preste. Então vamos ao que interessa.</p><p name="4e90" id="4e90" class="graf graf--p graf-after--p">Teste de software sempre foi um tema chato para tratar com qualquer developer. Não deveria ser pois, afinal, é uma tarefa que faz parte da profissão. Quem não testa software é como o engenheiro que projeta o avião e não testa se ele voa de verdade. E antes de seguirmos adiante no assunto, é preciso estabelecer de quem é a responsabilidade do teste.</p><h4 name="4bef" id="4bef" class="graf graf--h4 graf-after--p">Quem é o dono do macaco</h4><p name="3c64" id="3c64" class="graf graf--p graf-after--h4">Em uma empresa onde trabalhei havia um jargão comum: <em class="markup--em markup--p-em">este macaco é seu!</em>. A tradução do termo é simples: a responsabilidade de fazer esse negócio aí é sua. Se vira! Assim, quem é o dono do macaco quando falamos de teste de software?</p><p name="61c1" id="61c1" class="graf graf--p graf-after--p">O dono é você, o indivíduo que definitivamente escreveu o código. Por que? Porque você sabe onde o sapato aperta. Você sabe onde está mais frágil. E é sua responsabilidade garantir que os pontos frágeis aguentem as intempéries. Em um cenário otimista, a sua empresa tem um time especializado em testes e você entrega o seu trabalho para este time testar. Se sua empresa é uma startup, a sua responsabilidade é dobrada por que startup nenhuma que se preze tem dinheiro para ter o time de testes.</p><p name="0e6c" id="0e6c" class="graf graf--p graf-after--p">Mas, independentemente da presença do time de testes ou não, é sua responsabilidade garantir que o seu código não volte dos testes, ou que volte com pouca frequência.</p><h4 name="d38c" id="d38c" class="graf graf--h4 graf-after--p">Baixa qualidade</h4><p name="cedf" id="cedf" class="graf graf--p graf-after--h4">O que acontece quando seu trabalho começa a voltar com frequência da equipe de testes porque os cenários não funcionam? Acontece que a qualidade do seu trabalho é, no mínimo, ruim. Não importa se você usa teste automatizado ou não, o seu trabalho está uma bosta.</p><p name="9409" id="9409" class="graf graf--p graf-after--p">E por que baixa qualidade não é uma boa ideia? A motivação vai além da excelência técnica. A verdade é que quanto mais o seu trabalho volta, maior o tempo gasto com retrabalho. Tempo é um recurso escasso e pode ser vital para a lucratividade de um projeto.</p><p name="265b" id="265b" class="graf graf--p graf-after--p">Ninguém em sã consciência neste planeta desenvolve software que vai dar prejuízo. Ou o negócio dá retorno ou não presta. Ninguém pagará o seu salário se você consome recursos do projeto de maneira negligente, criando código que vive indo e voltando da equipe de testes. Isto significa que você é o próximo a ser obrigado a atualizar seu Linked-in.</p><h4 name="bea7" id="bea7" class="graf graf--h4 graf-after--p">Beleza técnica é conto da Carochinha</h4><p name="b961" id="b961" class="graf graf--p graf-after--h4">Agora é que o negócio pega. Foda-se se o seu código é feio. É isso mesmo! Foda-se! Foda-se se você não usa o mais fodão design pattern ou o framework pica das galáxias. O que importa, de verdade é se essa merda que você escreveu funciona e atende aos requisitos, além de ter baixo custo de manutenção.</p><p name="32ba" id="32ba" class="graf graf--p graf-after--p">Eu canso de repetir: desenvolver software comercial não é concurso de código bonito. Quer aparecer para suas negas? Vai escrever código em hackathon e criar story no Instagram. No dia-a-dia das empresas o que importa, de verdade, é entregar o projeto dentro do prazo e funcionando. E funcionando quer dizer: aguentando usuário fazendo o que não deve, lidando com falta de espaço em disco, falta de memória e qualquer outra intempérie que possa acontecer e que é inerente ao ambiente de produção.</p><p name="6090" id="6090" class="graf graf--p graf-after--p">No fim das contas o seu código precisa ser <em class="markup--em markup--p-em">bullet proof</em>, e isso é bem diferente de ser código bonito ou cheio de técnica chique. Precisa funcionar e aguentar o mundo real: excesso de processamento, falta de tempo de CPU porque o servidor sobrecarregou, falta de descritor de arquivo porque o processo abriu arquivo demais e por aí vai.</p><h4 name="db22" id="db22" class="graf graf--h4 graf-after--p">Como se garantir?</h4><p name="1f8b" id="1f8b" class="graf graf--p graf-after--h4">Teste automatizado é apenas uma das inúmeras ferramentas que você pode usar. Porém, há uma técnica que uso há anos e que tem sempre me dado bons resultados: desenvolvimento incremental. Sim, você já ouviu isso. As metodologias falam sobre isso. Mas pouca gente usa isso de verdade. A grande maioria ainda faz Big Bang: desenvolve tudo primeiro para depois testar.</p><p name="88bc" id="88bc" class="graf graf--p graf-after--p">Com o desenvolvimento incremental a dica é simples: faz um pouco, testa um pouco. Ao terminar todo o desenvolvimento, você já terá testado todo o seu código. Dessa forma cada nova camada de software que você adiciona é construída por sobre outra que já foi testada.</p><p name="0d0a" id="0d0a" class="graf graf--p graf-after--p">Existem outras técnicas que são extremamente úteis quando combinadas com o desenvolvimento incremental. Uma delas, que também uso bastante, é a argumentação de algoritmos. O princípio é relativamente simples:</p><blockquote name="71e6" id="71e6" class="graf graf--blockquote graf-after--p">A invariante de entrada, ao ser transformada pelo trecho de código em exame, leva à invariante de saída.</blockquote><p name="bf2c" id="bf2c" class="graf graf--p graf-after--blockquote"><em class="markup--em markup--p-em">Invariante</em> é algo que você assume como verdadeiro em determinado trecho do seu código. Você testa esta invariante através de uma <em class="markup--em markup--p-em">assertiva</em>. A assertiva falhará se a invariante for falsa, ou seja, inválida. Depois de executado o trecho que você quer validar, a invariante será, claramente, transformada e dará origem à invariante de saída. A invariante de saída é o resultado do processamento daquele trecho de código. Da mesma forma, é preciso testá-la com uma assertiva.</p><p name="16b1" id="16b1" class="graf graf--p graf-after--p">Se você comete um engano e faz com que uma informação chegue incorreta ao trecho de código em questão, as assertivas falham e você detecta imediatamente o problema, sem maiores dores de cabeça. Assim, sua responsabilidade é garantir com que todas as invariantes do seu código sejam sempre verdadeiras.</p><p name="413f" id="413f" class="graf graf--p graf-after--p">No fim das contas, se você escreve código com disciplina e cuidado, realiza os testes adequadamente e, o principal, deixa para escrever o código por último, certamente a sua codificação tem poucos erros e é de boa qualidade.</p><h4 name="2194" id="2194" class="graf graf--h4 graf-after--p">Pense antes de escrever a primeira linha de código</h4><p name="24ba" id="24ba" class="graf graf--p graf-after--h4">Um vício muito comum em desenvolvedores, principalmente os menos experientes, é sair escrevendo código assim que recebe a especificação ou lista de requerimentos. Por que isso é um tiro no pé e vai levar ao desenvolvimento de um código meia boca?</p><p name="9cb8" id="9cb8" class="graf graf--p graf-after--p">A primeira coisa que um desenvolvedor precisa fazer é entender qual é o problema que ele precisa resolver. Se, durante o processo, você disser coisas como “isso deve ser assim”, “eu acho que”, ou qualquer coisa que seja um indicativo de incerteza, pare imediatamente. Crie uma lista de perguntas e vá atrás dos stakeholders do projeto de forma a ter certeza sobre as coisas. Você precisa dizer “isto <strong class="markup--strong markup--p-strong">É</strong> assim”.</p><p name="8dc8" id="8dc8" class="graf graf--p graf-after--p">Nós trabalhamos com <strong class="markup--strong markup--p-strong">fatos </strong>e não com suposições. Se o seu requerimento é construído por sobre suposições, devolva-o ao seu scrum master, gerente de projeto ou seja lá quem é responsável pelo boteco e corra atrás de fatos. Software é preto no branco, zero e um. Coisas como TALVEZ simplesmente não existem. Ou é ou não é.</p><p name="cc92" id="cc92" class="graf graf--p graf-after--p">Bom, entendidos os fatos agora é hora de projetar o que você vai fazer. Você precisa modelar os dados, testar este modelo, checar se ele atende à necessidade de processamento de informação solicitada. Testado e validado o modelo, agora é hora de entender o fluxo de processamento do mesmo: o que entra, o que sai? Como os dados são transformados em informações? Quais as dependências?</p><p name="b760" id="b760" class="graf graf--p graf-after--p">Só depois disso tudo é que você precisa, efetivamente, escrever o código. Veja, o código é a última coisa que você vai fazer. O interessante de trabalhar assim é que a codificação torna-se, absolutamente, trivial, mesmo para problemas muito complicados. Por que? Porque você equacionou e efetivamente resolveu o problema antes de escrever a primeira linha de código. Assim, o código torna-se a expressão da sua solução. Ao invés de torrar dias escrevendo código, você usará dias entendendo, equacionando e resolvendo o problema e alguns minutos escrevendo o código que resolve isso.</p><p name="bb07" id="bb07" class="graf graf--p graf-after--p">Qual o benefício dessa abordagem? O código é mais simples, mais objetivo e claramente mais eficiente por que você não ficou dando voltas durante o desenvolvimento do raciocínio da solução do problema. Pense primeiro, escreva depois. Deus lhe deu esse cabeção para isso!</p><p name="ea44" id="ea44" class="graf graf--p graf-after--p graf--trailing">Happy Coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ronaldolima" class="p-author h-card">Ronaldo Faria Lima</a> on <a href="https://medium.com/p/274d3c42ecd3"><time class="dt-published" datetime="2019-12-06T14:28:04.215Z">December 6, 2019</time></a>.</p><p><a href="https://medium.com/@ronaldolima/o-conto-do-teste-de-software-274d3c42ecd3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 25, 2020.</p></footer></article></body></html>